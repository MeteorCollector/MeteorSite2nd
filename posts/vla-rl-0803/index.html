<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>VLA RL Aug '25 A | MeteorCollectorBlogs</title><meta name=keywords content="autonomous driving,VLA,diffusion,reinforcement learning"><meta name=description content="八月上旬看的文章放到这里"><meta name=author content="MeteorCollector"><link rel=canonical href=https://MeteorCollector.github.io/posts/vla-rl-0803/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0d7bdc28d739006af4c34db0d8752b71957f7a99895e0760dab3fd0110b9496c.css integrity="sha256-DXvcKNc5AGr0w02w2HUrcZV/epmJXgdg2rP9ARC5SWw=" rel="preload stylesheet" as=style><link rel=icon href=https://MeteorCollector.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://MeteorCollector.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://MeteorCollector.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://MeteorCollector.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://MeteorCollector.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://MeteorCollector.github.io/posts/vla-rl-0803/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://MeteorCollector.github.io/posts/vla-rl-0803/"><meta property="og:site_name" content="MeteorCollectorBlogs"><meta property="og:title" content="VLA RL Aug '25 A"><meta property="og:description" content="八月上旬看的文章放到这里"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-03T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-03T00:00:00+00:00"><meta property="article:tag" content="Autonomous Driving"><meta property="article:tag" content="VLA"><meta property="article:tag" content="Diffusion"><meta property="article:tag" content="Reinforcement Learning"><meta property="og:image" content="https://MeteorCollector.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://MeteorCollector.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="VLA RL Aug '25 A"><meta name=twitter:description content="八月上旬看的文章放到这里"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://MeteorCollector.github.io/posts/"},{"@type":"ListItem","position":2,"name":"VLA RL Aug '25 A","item":"https://MeteorCollector.github.io/posts/vla-rl-0803/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"VLA RL Aug '25 A","name":"VLA RL Aug \u002725 A","description":"八月上旬看的文章放到这里","keywords":["autonomous driving","VLA","diffusion","reinforcement learning"],"articleBody":" 本篇从老站点迁移而来，公式可能不太舒服，见谅\nB2DVL完事了，看看最近的论文 一般来讲，越靠上的越新\nDiffusion DiWA: Diffusion Policy Adaptation with World Models Akshay L Chandra1∗, Iman Nematollahi1∗, Chenguang Huang2 Tim Welschehold1, Wolfram Burgard2, Abhinav Valada1 1 University of Freiburg 2 University of Technology Nuremberg\narxiv github (2~3个月之前开源, 23 stars) website\n这篇论文叫 《DiWA: Diffusion Policy Adaptation with World Models》，它提出了一种全新的方法，让机器人可以在完全不接触真实环境的情况下，通过“想象”来提升已有的技能，尤其适用于基于扩散模型（Diffusion Policy）的机器人控制策略。\nDiWA 是第一个完全离线的扩散策略微调框架，它用一个世界模型代替真实环境，让机器人通过“在脑子里练”来提升技能，不需要任何额外真实交互，却比传统在线强化学习方法更高效、更安全。\nDiWA 的核心思路 阶段 任务 方法 1. 世界模型训练 学会“想象” 用大量无标签的机器人自由探索数据训练一个世界模型，能预测未来状态 2. 策略预训练 学会“模仿” 用少量专家演示数据预训练一个扩散策略（Diffusion Policy） 3. 奖励建模 学会“目标” 用专家数据训练一个奖励分类器，判断某个状态是否接近任务成功 4. 离线微调 学会“改进” 在世界模型里做强化学习（PPO），通过“想象的轨迹”来微调策略 实验结果 ✅ 模拟环境（CALVIN benchmark）\n方法 成功率 是否在线交互 交互次数 原始扩散策略 57.8% ❌ 0 DiWA（离线微调） 82.3% ❌ 0 DPPO（在线微调） 82.3% ✅ 250万次 ✅ 真实世界（Franka机器人）\n任务 原始策略 DiWA微调后 打开抽屉 55% → 85% 关闭抽屉 60% → 95% 推滑块 55% → 87% 技术亮点 模块 作用 技术细节 Dream Diffusion MDP 把扩散过程建模为强化学习问题 把每一步“去噪”看作一个动作，整个世界模型作为环境 世界模型（World Model） 替代真实环境 基于DreamerV2架构，支持长时序预测 奖励分类器 代替真实奖励 用专家数据训练一个二分类器，判断状态是否成功 行为克隆正则化 防止“钻空子” 限制策略不要太偏离原始行为，避免利用世界模型的缺陷 Reinforcement Learning for Flow-Matching Policies Samuel Pfrommer, Yixiao Huang, Somayeh Sojoudi（UC Berkeley）\narXiv:2507.15073v1 [cs.LG] 20 Jul 2025 Reinforcement Learning for Flow-Matching Policies\n这个论文到现在两个月了，github repo 仅有 4 star，难说靠不靠谱。看起来就是给 flow matching 上了 GRPO 来试试效果。\n本文首次系统地把强化学习（RL）用于“流匹配（flow-matching）”策略的二次优化，使其能够超越次优演示数据，并支持可变时域的最短时间控制；提出了两种方法——RWFM（加权模仿）与 GRPO（组相对策略优化），在仿真独轮车任务上将演示策略成本降低 50–85%。\n研究背景\n• 现代通才机器人策略（VLA 模型，如 π0、RT-2、Octo）普遍采用“流匹配 / 扩散”动作专家，通过模仿学习一次性生成固定长度动作块。\n• 但人类演示存在两类次优：\n– 变异性次优（variation suboptimality）：同一指令下动作优劣不一。\n– 支撑集次优（support suboptimality）：演示未覆盖更优动作轨迹。\n• 固定长度动作块也无法实现“尽快完成任务”的最短时间目标。 主要贡献\n(1) 形式化流匹配策略的 RL 问题，指出需同时解决上述两类次优。\n(2) 在流匹配框架中引入“时域通道”，让模型可生成任意长度的动作轨迹，实现可变时域规划。\n(3) 提出两种 RL 微调方法：\n• RWFM（Reward-Weighted Flow Matching）：在模仿损失中用指数奖励加权，并加入高斯“bump”探索噪声，使策略逐渐偏向高奖励轨迹并突破演示支撑集。\n• GRPO（Group Relative Policy Optimization）：\n– 采用免价值函数的 PPO 变体 GRPO，提升样本效率；\n– 训练一个轻量级奖励代理 $( R_\\varphi(\\tilde{o}, A) )$ ，在无需真实 rollout 的情况下即可估计动作块奖励；\n– 组内相对优势计算 + 加权流匹配损失，显著减少与环境交互次数。\n(4) 在 6 种奖励设定（位置、时间、速度、碰撞、朝向、控制正则）的 2D 独轮车环境上验证：\n• 纯模仿（ILFM）只能复现演示水平；\n• RWFM 显著提升，但仍受限于在线 rollout 成本；\n• GRPO 用更少交互量达到最佳，平均成本比 ILFM 低 50–85%。\n(5) 消融实验显示：\n• 奖励缩放 $\\alpha$ 过大易导致策略忽视观测条件；\n• 动作探索幅度 $M \\approx 0.2$ 对突破支撑集最有效，能让策略学会演示中未出现的“刹车”行为。 方法要点\n• 可变时域：把原始轨迹插值到统一长度 $H^\\prime$，并拼接“期望时域”额外通道；生成时再反推真实步数。\n• RWFM：在演示数据上按 $\\mathrm{e}^{\\alpha R}$ 加权做流匹配，随后用当前策略收集高奖励轨迹继续训练。\n• GRPO：\n– 预训练阶段先用演示数据训练奖励代理 $R_\\varphi$（TimesNet 架构）。\n– 每轮采样 G=10 条动作块，用 $R_\\varphi$ 计算组内优势，加权更新流匹配网络。\n– 仅在验证性能停滞时才进行真实环境的少量 rollout，以校正奖励代理。 Transition Matching: Scalable and Flexible Generative Modeling Meta\nFlow Matching 的改进，airxiv\n这篇文章的话，已经有珠玉在前。有一篇讲 transition matching 的知乎文章，顺带讲了一些 flow matching 的原理： Transition Matching: Scalable and Flexible Generative Modeling （公式看晕了，喂！） - 知乎\n另外记一下 velocity：\n在 Flow Matching 中，velocity（速度场） 是一个向量场，描述了如何从噪声（源分布）一步步“流动”到真实数据（目标分布）。\n在 Flow Matching 中，我们假设：\n有一个源分布 $p_0(x)$（通常是标准高斯）； 有一个目标分布 $p_1(x)$（真实数据分布）； 我们希望构造一条连续的路径（flow），把 $p_0$ 变成 $p_1$。 这个路径是通过一个**常微分方程（ODE）**来定义的：\n$$ \\frac{dx_t}{dt} = v(x_t, t), \\quad t \\in [0, 1] $$\n其中：\n$x_t$ 是时间 $t$ 时的中间状态； $v(x_t, t)$ 就是所谓的 velocity field（速度场），它告诉我们在每个位置 $x_t$ 和时间 $t$ 应该朝哪个方向“移动”。 假设现在有一个点 $x_0$ 从标准高斯采样出来，目标是变成一张猫的图片 $x_1$。\nvelocity $v(x_t, t)$ 就是每一步告诉你：\n“你现在在这个位置 $x_t$，下一步应该往哪个方向走，才能更接近真实的猫图？”\n这个速度场是用一个神经网络 $v_\\theta(x_t, t)$ 来学习的。\n方法 如何移动 扩散模型（Diffusion） 通过加噪/去噪，每一步是随机扰动（SDE） Flow Matching 通过确定性速度场，每一步是直接移动（ODE） Steering Your Diffusion Policy with Latent Space Reinforcement Learning Wagenmaker 等，UC Berkeley \u0026 UW\narXiv:2506.15799v2 [cs.RO] 25 Jun 2025 arxiv github\n一句话总结 DSRL 把 RL 的作用域从“改权重”变成了“改噪声”：在保持预训练扩散/流匹配策略权重冻结的前提下，仅在其输入噪声空间里学一个小策略，就能在极少交互下把成功率从 20 % 提到 90 %，并首次实现了 π0 这类 3.3 B 通用机器人策略的在线 RL 微调。\n1. 研究动机\n行为克隆（BC）+ 扩散策略（$\\pi_{\\mathrm{dp}}$）已成为通才机器人控制的主流，但遇到新场景往往表现不佳。 传统 RL 微调需更新大模型权重，代价高且不稳定；后处理动作或残差策略又效率低。 关键观察：扩散模型是 “给定初始噪声 $\\rightarrow$ 确定性去噪 $\\rightarrow$ 动作” 的映射，因此只需控制噪声即可控制动作。 2. 核心思路：Diffusion Steering via RL (DSRL)\n把原 MDP 重写成 “噪声-动作” MDP $M^w$：\n状态 $s ;\\to;$ 选噪声 $w ;\\to; \\pi_{\\mathrm{dp}}(s,w)$ 输出动作 $a$。 在 $M^w$ 上用任意 RL 算法学一个小策略 $\\pi_w(s) \\to w$，完全不碰 $\\pi_{\\mathrm{dp}}$ 权重。 好处： 黑盒、无需反向传播多步去噪链； 参数量缩小几个数量级，可在真实机器人 1 GPU 上在线训练； 即插即用，适用于扩散/流匹配、DDIM/DDPM、专有或开源大模型。 3. 方法细节\n(1) 噪声别名 (Noise Aliasing) 技巧\n同一动作可能由不同 $w$ 得到，利用这一点把离线数据转成 $w$-Q 值，提升样本效率； 提出 DSRL-NA：两个 critic（$Q_A$ 在动作空间，$Q_W$ 在噪声空间），$Q_W$ 通过 $Q_A$ 蒸馏 + 别名映射，实现离线/在线统一。 (2) 训练流程 – 预训练 πdp（冻结）→ 在噪声空间初始化 π_w、Q_w → 在线/离线 RL 更新 π_w。 – 仅需前向推理 πdp，无需梯度回传。\n实验亮点 • 在线适应：在 Robomimic、OpenAI Gym、真实 Franka / WidowX 上，DSRL 用 5–10× 更少交互即可超过 DPPO、IDQL 等最新方法。 • 离线适应：在 10 个 OGBench 任务中，DSRL 有一半任务是 SoTA，且只需用同一份离线数据。 • 真实世界： – 单任务 Cube→Bowl：BC 20 % → DSRL 90 %（\u003c50 回合）。 – 多任务 Bridge-V2 预训练：DSRL 在 100–150 回合内显著改善抽屉、堆叠等任务。 – π0（3.3 B）微调：Libero 任务 20 %→100 %（∼1 万步），Aloha 双手机器人任务显著超越 RESIP/V-GPS；首次在真实 Franka 上成功微调 π0。 消融与洞察 • 噪声别名可把在线样本效率再提高 2×。 • 即使 πdp 训练数据质量差、过拟合或网络小，DSRL 仍能快速“拉回”性能。 • 去噪步数、网络规模对 DSRL 几乎无影响；限制噪声幅值 $b_w \\in [1,3]$ 即可保证稳定性。 局限与未来方向 • 若 πdp 动作分布极度集中，可能无法提供足够可操纵的噪声空间； • 仍需奖励设计与环境重置； • 未来可探索： – 将“噪声”拓展到 prompt / 观测空间； – 理论刻画噪声空间表达能力； – 无奖励或自动奖励设定。 DSRL 把“微调大模型”变成“微调小噪声”，让真实机器人用几十次交互就能把 20 % 成功率飙到 90 %，并首次把 RL 成功塞进 3.3 B 参数的通用策略 π0，为现场自适应打开了实用大门。\nHierarchical Rectified Flow Matching with Mini-Batch Couplings github repo 还没开源而且仅有一个 star。\nYichi Zhang, Yici Yan, Alex Schwing, Zhizhen Zhao\nUniversity of Illinois Urbana-Champaign\n提出了一种改进的流匹配方法（HRF），通过小批量最优传输（mini-batch optimal transport）来简化速度场的多模态分布，从而提升生成质量和效率，尤其适用于低计算预算（低NFE）场景。\n流匹配（Flow Matching） 是一种生成模型方法，通过建模一个速度场（velocity field） 来将简单分布（如高斯）转换成复杂数据分布。它通过数值积分一个常微分方程（ODE）来生成样本。\n但传统流匹配存在两个问题：\n速度场是多模态的，难以建模； 路径弯曲，导致采样效率低。 层次流匹配（Hierarchical Rectified Flow, HRF） 被提出用于建模速度场的分布，但它在每一层的复杂度都很高，没有简化建模过程。\n作者提出：通过小批量耦合（mini-batch couplings）来逐步简化速度场的复杂度，从而改善生成质量和效率。具体包括：\n数据空间耦合（Data Coupling）\n不再独立采样源分布和数据点，而是用小批量最优传输（mini-batch OT）来配对样本。 结果：速度场分布变得更单峰（unimodal），更容易学习。 速度空间耦合（Velocity Coupling）\n在速度空间中，也用小批量OT来配对初始速度 $v_0$ 和目标速度 $v_1$。 结果：采样路径更直，减少积分步数（NFE），尤其适用于低预算采样。 联合耦合（Data + Velocity Coupling）\n两阶段训练：先用数据耦合训练，再用速度耦合微调。 结果：在低NFE（如1步）下也能生成高质量样本。 之后有需要了再细看吧。。\nRL4AD CaRL: Learning Scalable Planning Policies with Simple Rewards Bernhard Jaeger et al. University of Tübingen） 熟悉的作者，熟悉的配方\narxiv github\n有一说一，这个工作非常 straightforward。RL是非常 consume rollout 次数的，我觉得 CARLA 直接练还是很难加速，资源消耗太大了，必须尽量避免如此直接的方法，除非有什么魔法能不用练几下就能达到很好的效果，比如有一个很好的 backbone VLA 只需要少许微调，不用在 CARLA 上从零开始。但是他这个说是 Due to these optimizations, we were able to reproduce Roach with 10 million environment samples in 32 hours on a single A100 GPU. 如果这样的话，倒还好。\nCaRL 提出了一种极简的强化学习奖励设计，仅用“路线完成度”+惩罚项，就能在大规模数据下训练出高效、鲁棒的自动驾驶规划策略，在 CARLA 和 nuPlan 上都取得了 SOTA 性能。\n极简奖励设计（Simple Reward） 只用一个奖励项：路线完成度（Route Completion, RC）\n奖励公式： reward = RC * ∏(soft penalty) - terminal penalty 软惩罚：如超速、偏离车道、舒适性等，乘性衰减；\n硬惩罚：如碰撞、闯红灯，直接终止 episode；\n无规则参考：不依赖任何规则系统，避免性能上限。\n可扩展训练（Scalable Training） PPO 在大 batch size 下失效：复杂奖励在大 batch 下容易陷入局部最优； 简单奖励可扩展：在大 batch 下性能反而提升； 训练规模： CARLA：300M samples（30× 以往工作） nuPlan：500M samples 使用 8-GPU 单机训练，DD-PPO 分布式训练框架 工程优化 CARLA 训练加速： 不重启 town、预计算 A* 路径 异步数据收集（AC-PPO） 场景自动生成脚本 nuPlan 适配： 增加 survival bonus 防止提前完成任务后“摆烂” Action Space Reduction Strategies for Reinforcement Learning in Autonomous Driving arxiv 暂未开源…\n是一个在 CARLA 里 RL 的小改进，就是减小动作空间。具体在训练上也是直接 PPO，倒是创新性有限（？）。\n论文提出两种新方法（动态掩码 + 相对动作）来“聪明地砍掉无用动作”，\n在 CARLA 仿真中让 PPO 智能体训练提速 2 倍，成功率更高，驾驶更平滑。\n提出的两种新方法 方法 核心思想 动作空间大小 特点 Dynamic Masking 每帧只保留当前方向盘 ±0.2 范围内的 5 个转向 + 2 个油门，其余动作被二进制掩码设为无效 仍为 42 维，但有效动作只剩 5×2=10 个 实时、上下文相关，避免无效探索 Relative Reduction 动作改为“相对调整”：{-0.2, -0.1, 0, 0.1, 0.2}，加到当前方向盘上** 固定 5×2=10 维 动作空间维度不变，但物理意义更平滑，天然限制越界 实验验证（CARLA Town07） 指标 结果 训练时间 动态/相对方法比“全动作空间”快 2 倍 成功率 Rel-0.5 和 Dyn-0.5 在大多数场景 ≥ 70%，甚至 100% 控制平滑性 车道偏离显著降低（Rel-0.5 仅 0.10 m vs 全动作 0.31 m） 复杂场景 多转弯、十字路口也能稳定完成 关键结论 动作空间不是越大越好——合理缩减反而提升性能。 动态掩码 和 相对动作 在 速度、成功率、平滑性 之间取得最佳平衡。 可移植性高：方法独立于网络结构，可插拔到任何 RL 框架（PPO、SAC、DDPG 等）。 Reinforcement Learning with Action Chunking arxiv 未有开源代码\nQiyang Li, Zhiyuan Zhou, Sergey Levine. UC Berkeley\n我对 RL 还并不内行，之后再细看\n这篇论文《Reinforcement Learning with Action Chunking》提出了一种简单但高效的强化学习方法（Q-chunking），专门解决长周期、稀疏奖励任务在离线到在线（offline-to-online）RL场景下的探索困难和样本效率低的问题。\n✅ 一句话总结： Q-chunking 把“动作序列”当作一个整体来训练和探索，使得 RL 在稀疏奖励任务中能更快、更稳地从离线数据中学到东西，再在线微调。\n🎯 核心思想：动作分块（Action Chunking） 传统 RL Q-chunking 每一步预测一个动作 每次预测一个动作序列（chunk），比如未来 5 步 探索靠随机扰动 探索靠模仿离线数据中的连贯行为，更高效 1 步 TD 更新慢 使用无偏的 n 步 TD 更新，更快传播价值信号 💡 关键技术点 模块 说明 动作空间扩展 把动作从 a_t 变成 a_t:t+h，即一个长度为 h 的序列 行为约束 用 Flow Matching 学一个行为策略，限制策略不过度偏离离线数据 无偏 n-step TD 用完整的动作序列做 TD 更新，避免传统 n-step 的偏差问题 两种实现 QC（基于 best-of-N 采样）和 QC-FQL（基于 Flow Q-learning） 🧪 实验结果 基准 表现 OGBench（5 个任务） Q-chunking 在最难的 cube-quadruple 上远超所有基线 Robomimic（3 个任务） 在 lift/can/square 上均优于 RLPD、FQL 等 样本效率 仅用 100 万步在线训练就能解决原本几乎学不到的任务 探索质量 动作更连贯，覆盖更多状态空间，避免“原地抖动” Q-chunking 通过“动作序列预测 + 行为约束 + n-step TD”，让 RL 在稀疏奖励任务中更快、更稳地从离线数据中学到策略，适用于机器人操作等长周期任务。\nBreaking Imitation Bottlenecks: Reinforced Diffusion Powers Diverse Trajectory Generation Ziying Song, Lin Liu, Hongyu Pan, Bencheng Liao, Mingzhe Guo, Lei Yang, Yongchang Zhang, Shaoqing Xu, Caiyan Jia, Yadan Luo\narxiv 暂无开源\ndp + rl，好文。多条轨迹候选我觉得也是一个可行的方式，像之前张兆翔那篇也是这么搞的，预制几个然后diffusion出来实际的。不过他搞了 diffusion policy + rl,领先一步,而且做得非常扎实.应当多看\n这篇论文提出 DIVER —— 首个用 扩散模型 + 强化学习 的端到端自动驾驶框架，专门解决传统模仿学习中“模式崩溃、轨迹单一、过于保守”的顽疾，让车辆真正生成多样化且安全可行的未来轨迹。\n核心痛点\n• 现有方法只用一条专家轨迹做模仿，导致：\n– 所有预测轨迹都“挤”在专家轨迹附近 → 模式崩溃\n– 不敢变道/超车，无法应对复杂场景\nDIVER 的解法（三步走）\nPolicy-Aware Diffusion Generator (PADG)\n‑ 同时输入：地图、周边车辆、多条参考轨迹（变道、让行、超车…）\n‑ 扩散模型一次性生成 M 条多样轨迹，而非单条均值轨迹\n强化学习“纠偏”\n‑ 把扩散过程视为随机策略\n‑ 用 GRPO 优化多样性奖励 + 安全性奖励：\n• 多样性：轨迹间距离越大越好\n• 安全：离障碍物越远越好\n新指标 \u0026 训练损失\n‑ 提出 Diversity Metric（[0,1] 范围）专门衡量多模态轨迹离散度\n‑ 用 匈牙利匹配损失 将每条预测轨迹对齐到不同参考意图，避免收敛到同一均值\n实验结果\n• Bench2Drive 闭环：成功率 ↑29 %、超车能力 ↑3.8 %、紧急制动 ↑5.5 %\n• NuScenes 开环：平均多样性指标 ↑61 %，碰撞率 ↓12.5 %\n• 在转弯、对抗、雨雪雾等子集上均优于 VAD、SparseDrive、DiffusionDrive 等 SOTA\nDIVER 把“扩散去噪过程”当成一个可学习的随机策略（policy），然后用 Group Relative Policy Optimization（GRPO） 做 RL 微调，核心流程如下：\nrl 做 dp 详细方法 1. 把扩散模型当策略\n扩散模型每一步的 denoising 网络 εθ(τt, t) 就是策略 πθ 输入：当前噪声轨迹 τt + 场景条件 输出：下一步去噪方向（相当于动作） 2. 设计两条 reward 信号\n奖励 公式（直觉） 作用 多样性奖励 rdiv 1/M(M-1) Σ‖τi − τj‖₂ 最大化轨迹间距离，防止模式崩溃 安全奖励 rsafe −1/T Σ 𝟙[Dsafety(xt) \u003c dthresh] 离障碍物越近惩罚越大，保证物理可行 总奖励：r(τ) = rdiv + λ·rsafe\n3. 用 GRPO 更新策略\n对每个场景采样 G 条轨迹（group） 计算组内 相对优势（relative advantage）：\nAi = ri − mean(rgroup) GRPO 目标：\nJGRPO = E[min(wi Ai, clip(wi,1±ε) Ai)] − β·DKL(πθ‖πref)\nwi = πθ/πold（重要性采样比） 4. 训练损失组合 Ltotal = λmatch·Lmatch + λRL·LRL\nLmatch：匈牙利匹配损失，保证每条预测轨迹对齐不同意图 LRL：GRPO 损失，直接用不可微的 rdiv + rsafe 优化扩散策略 结果 无需手工标签，仅靠奖励即可让扩散模型**“敢变道”、“懂避障”** 在闭环 Bench2Drive 上：成功率 ↑29 %，多样性 ↑66 %，碰撞率 ↓12 % DIVER 把扩散去噪视为策略，用 GRPO + diversity/safety reward 直接微调，突破了模仿学习的“单专家”枷锁。\nDYNA: Reinforcement Learning in Real World Research - DYNA Robotics | Research 这个不是论文,,,\nVLA FedVLA: Federated Vision-Language-Action Learning with Dual Gating Mixture-of-Experts for Robotic Manipulation Cui Miao1 TaoChang1 MeihanWu1 HongbinXu2 Chun Li3 MingLi4* Xiaodong Wang1 1 National University of Defense Technology 2Bytedance Seed 3Shenzhen MSU-BIT University 4Guangdong Laboratory of Artificial Intelligence and Digital Economy (SZ)\narxiv\n分布式训练 VLA，现在我这边可能不太需要吧，先放在这\n这篇文章提出了一种名为 FedVLA 的联邦学习框架，用于在机器人操作任务中训练 视觉-语言-动作（VLA）模型，同时保护用户隐私。文章的核心贡献是解决了如何在分布式环境中高效训练多模态机器人模型，同时避免集中式训练带来的隐私风险。\nFedVLA 是第一个用于机器人操作任务的联邦视觉-语言-动作学习框架，它通过“任务感知特征提取 + 双向专家选择 + 专家驱动的聚合策略”，在保护隐私的同时实现了接近集中式训练的性能。\nFedVLA 的三大创新模块 模块名称 作用 关键技术 IOSP（Instruction-Oriented Scene-Parsing） 把图像分解为“任务相关”的对象表示 用CLIP模型将图像中的目标物体、周围物体、背景物体与语言指令对齐 DGMoE（Dual Gating Mixture-of-Experts） 让模型根据任务复杂度动态选择专家，提高计算效率 引入“自感知专家”，专家可以主动决定是否接收token，实现双向选择 EDA（Expert-Driven Aggregation） 在联邦聚合时，优先合并“专家选择相似”的客户端模型 利用专家激活向量计算客户端之间的相似度，动态分配聚合权重 实验验证 ✅ 模拟环境（Meta-World）\n任务：关门、关抽屉、扫地、开窗 FedVLA 成功率：63.3%（vs 集中式 65.0%，FedAvg 51.7%） ✅ 真实世界（UR3机械臂）\n任务：清理桌面、扔垃圾、开抽屉、分药 FedVLA 成功率：63.3%（vs 集中式 63.4%，FedAvg 53.3%） VOTE: Vision-Language-Action Optimization with Trajectory Ensemble Voting arxiv [github](https://github.com/LukeLIN-web/VOTE 仅几天前开源，16stars)\nVOTE 提出“单令牌动作 + 投票集成”的轻量级 VLA 框架，把生成动作所需的 token 数量从上百个压缩到 1 个，同时在推理阶段用历史预测投票纠错，实现 39× 推理加速、98% LIBERO 成功率，并能在边缘设备 46 Hz 实时运行。\n传统 VLA 模型 问题 多 token / 扩散动作头 推理慢：OpenVLA/CogACT 每步 200 ms 以上 只执行当前预测 动作浪费：上一帧预测被丢弃，轨迹抖动 3D/扩散增强 训练贵：显存大、梯度步数多 1️⃣ 训练阶段：单令牌动作 在 LLM tokenizer 内新增 特殊 token 一次前向只生成 1 个 token → 隐藏态直接输入轻量 MLP 动作头 token 数从 N×D ↓ 1（N=chunk, D=action dim） LoRA+瓶颈 MLP，训练步数≈OpenVLA-OFT 的 15–54 % 2️⃣ 推理阶段：Trajectory Ensemble Voting 维护一个 K+1 步动作委员会（历史+当前） 用余弦相似度投票，选多数派平均值作为最终动作 τ=0.5 经验阈值即可，无需调参 融合后轨迹更平滑，平均提升 5–10 % SR 场景 数据量 成功率 延迟/吞吐 边缘设备 LIBERO-4 套件 50–130K 步 98 % 78 ms / 102 Hz 46 Hz @Jetson Orin SimplerEnv-WidowX 60K 步 58 % 78 ms 实时 Google Robot 150K 步 74 % 78 ms 实时 比 OpenVLA 快 39×，显存占用 -50 % 比 CogACT 高 7 % SR，边缘设备 CogACT OOM VOTE 用“1 个 token 生成整个动作块 + 历史投票纠错”，让 VLA 模型在边缘设备上也能以 46 Hz 的实时速度完成高成功率机器人操作。\n训练用数据 1️⃣ 数据模态\n模态 说明 RGB 图像 1 张 224×224 第三人称相机图像（或更多视角可扩展） 语言指令 自然语言任务描述（如 “put the cup on the table”） 动作标签 连续 7-DoF 末端位姿 + 1 维夹爪开闭（共 8 维） 动作块（chunk） 连续 N 步动作序列（N=8 或 16，按实验设定） 无需深度图、点云、3D 姿态等额外模态，保持极简输入。\n2️⃣ 数据量（按任务/场景）\n场景 单任务数据量 总数据量 备注 LIBERO 基准 50–130K 步 4 个任务 × 50–130K ≈ 200–520K 步 每个任务 500 条演示 × 100 步 SimplerEnv 60K 步 1 个任务 ≈ 60K 步 BridgeDataV2 子集 真实机器人 类似量级 视任务而定 论文未明确，但经验值 50–200 条演示/任务 数据量远小于 OpenVLA-OFT（后者需 150K 步 × 64 batch）。\n计算资源\n阶段 硬件需求 训练时间 显存占用 备注 微调 VLA（LoRA） 2×H100 (94GB) 8–130K 步（1–3 天） 14–19 GB 全局 batch=40，LoRA rank=32 边缘推理 NVIDIA Jetson AGX Orin (32 GB) 实时 46 Hz 346 ms 延迟 无需再训练 对比基线 8×A100 (80GB) 150K 步 × 64 batch 19 GB OpenVLA-OFT 资源 VOTE 仅需 RGB + 语言 + 动作轨迹，单任务几十到几百条演示，2×H100 上 1–3 天即可微调完成，边缘设备实时运行。\nVideo Generators are Robot Policies Junbang Liang, Pavel Tokmakov, Ruoshi Liu, Sruthi Sudhakar, Paarth Shah, Rares Ambrus, Carl Vondrick\narxiv 未开源\n不看好非要生成视频的模型，跑不起来… 8*A100 练两周真绷不住了\n本文提出“Video Policy”：用大规模视频生成模型当“世界模拟器”，再配一个轻量级动作解码器，就能把生成视频直接变成机器人策略，实现少量动作数据、强鲁棒性的泛化控制**。\n📌 核心思路：把“视频生成”当策略 先视频：用 Stable Video Diffusion (SVD) 级联模型，根据 初始图像 + 语言任务 生成未来机器人执行视频帧。 后动作：用 轻量级 1D-CNN U-Net 从视频隐藏层特征解码 7-DoF 末端位姿 + 夹爪开闭 的连续动作序列。 因为 SVD 已在互联网海量视频里学到通用动力学，动作解码器只需 50~200 条演示即可泛化。\n📌 训练与数据 阶段 数据 计算资源 说明 视频预训练 互联网通用视频 8×A100，两周 微调 SVD 动作微调 每任务 50 条人演示（或 300M MimicGen） 同上 冻结视频权重，只训动作头 真实世界 200 条/任务（5 任务） RTX 4070 Laptop 实时 30 步扩散推理 📌 主要结果 Benchmark 数据量 平均成功率 对比 RoboCasa-24 任务 50 demo 66% 超 DP-ResNet、UVA、GR00T 等 LIBERO-10 50 demo 94% 显著优于 UVA 真实 5 任务 200 demo 0.3-1.0 对未见物体/背景/位置均泛化 📌 关键发现 2-阶段训练 \u003e 联合训练：先训视频再训动作，效果更好（63% vs 57%）。 越长视频预测越泛化：32 步视频预测在分布偏移任务上收益最大。 无动作视频也能泛化：仅动作头训 12/24 任务，靠视频先验仍超过基线。 实时瓶颈：25 帧 256×256 在 A100 上需 ~9 秒，但加速技术可解。 Pre-training Auto-regressive Robotic Models with 4D Representations ARM4R ——用“人视频里学 4D 轨迹（3D 点+时间）”来预训练机器人策略，结果只用 1/10 的机器人数据就超过了 OpenVLA、π0-FAST 等 SOTA 方法说是。而且他这个用的资源也不多：“Finally, we use 4 NVIDIA A6000 GPUs for training and a single NVIDIA A6000 GPU for evaluation.”\n先插一嘴，它的网站做得不错，分两栏，左边图片右边文字。虽然也是套模板，但是做了点小改动：website 但是看多了也就那样，对手机用户不太友好。\nARM4R 的完整模型 =「四路编码器 + 一个自回归 Transformer + 解码器」。下面给出可直接落地的架构细节与训练脚本骨架（PyTorch 伪码），按三阶段顺序展开。\n──────────────────\n模型架构 输入 (t 时刻) ├─ 语言指令 l → 冻结 CLIP-T 文本编码器 → z_l ├─ 图像 i_t → 冻结 ViT-B/16 → z_i ├─ 3D 点/机器人状态 p_t → 2 层 MLP → z_p └─ 历史信息 → 拼接后喂给 Causal Transformer Transformer：随机初始化 ViT-Base（12 层、768 维、8 头），因果注意力，窗口 C=16（或32）。 输出 ├─ 未来 3D 点 p_{t+1}（Stage1/2）或未来机器人状态 s_{t+1}（Stage3） └─ 解码：2 层 MLP 直接回归，L1 loss 数据与预处理 阶段 数据 伪标签生成 采样率 Stage1 Epic-Kitchens100 76k 视频 SpatialTracker 产生 3D 点轨迹（g×g 网格） 10 fps Stage2 1–2 k 机器人演示视频 同上 10 fps Stage3 190 × 任务变体 成功轨迹（末端位姿+夹爪） 无伪标签，直接用机器人真值 10 fps 把整个流程封装成 「人视频→3D 轨迹预训练」→「机器人视频→3D 轨迹微调」→「机器人动作→控制微调」，只需替换最后一步的 MLP 头即可。\n训练过程 ──────────────────\n阶段 1：人视频 4D 轨迹预训练\n• 数据\n– 76 k 条 Epic-Kitchens100 egocentric 人视频（75 041 条有效）。\n– 无人工动作标签，只用 伪 3D 点轨迹：\n- 在首帧布 g×g 网格 → SpatialTracker 产生每帧 3D 坐标（相机坐标系）。\n• 训练任务\n– 「给定语言指令 + 当前图像 + 当前 3D 点 p_t → 预测 t+1 的 3D 点 p_t+1」。\n– 采用 自回归 next-token 范式，损失为 L1(p̂_t+1, p_t+1)。\n──────────────────\n阶段 2：机器人场景 4D 轨迹微调（一次即可，跨任务共享）\n• 数据\n– 每条任务仅 5–10 % 阶段 1 数据量，即 1–2 k 段机器人演示视频。\n– 仍用 SpatialTracker 产生 3D 点轨迹，但相机固定，场景为机器人。\n• 训练任务\n– 与阶段 1 相同：预测 3D 点 → 解决人→机器人相机/场景分布差异。\n──────────────────\n阶段 3：机器人控制微调（任务专用）\n• 数据\n– 190 段成功演示/任务（比基线少 10×）。\n– 观测：语言指令 + 图像 + 机器人当前状态 s_t（末端位姿+夹爪）。\n– 标签：下一时刻状态 s_t+1。\n• 训练任务\n– 把阶段 1/2 的 3D 点输入/输出通道 换成 机器人状态通道；\n– 仍用自回归 Transformer，损失 L1(ŝ_t+1, s_t+1)。\n– 预测 16 步，执行第 1 步（滚动时域）。\n──────────────────\n把「人视频里学 3D 点轨迹」→「机器人视频里继续学 3D 点轨迹」→「把预测目标换成机器人状态」，总共使用的数据有：\n大量无标人视频（+ SpatialTracker 伪轨迹）； 少量机器人演示视频（同伪轨迹）； 目标任务少量成功轨迹（用于阶段 3）。 MP1: MeanFlow Tames Policy Learning in 1-step for Robotic Manipulation arxiv\n北大的工作，刚开源三周左右，10 stars\nMP1 是第一个将 MeanFlow（平均速度场）引入机器人操作任务的方法，\n仅用 1 步推理（1-NFE）即可输出高质量动作轨迹，\n在多个仿真与真实任务中显著优于扩散模型（如 DP3）和流模型（如 FlowPolicy）。\n方法类型 优点 缺点 Diffusion Policy（如 DP3） 多模态、鲁棒性强 推理慢（需 10+ NFE） Flow Policy（如 FlowPolicy） 1-NFE 推理快 需一致性约束，误差大 MeanFlow（图像生成） 1-NFE、无需一致性 尚未用于机器人任务 ❗ MP1 首次将 MeanFlow 引入机器人学习，解决“快 vs 准”的权衡问题。\n模块 设计 作用 MeanFlow Identity 直接建模平均速度场，绕过 ODE 积分 实现真正 1-NFE 推理 Dispersive Loss 无正样本的对比正则项，拉开不同状态嵌入 提升少样本泛化能力 CFG（Classifier-Free Guidance） 增强可控性 不影响 1-NFE 推理速度 3D Point Cloud Input 使用 512/1024 点云作为视觉输入 提升空间理解能力 原理 输入处理\n视觉输入：3D 点云 → 3D Projection → 特征向量 fv 状态输入：机器人关节状态 → 全连接层 → 特征向量 fs 条件向量：c = concat(fv, fs) MeanFlow 建模\n$$u(z_t, r, t) = \\frac{1}{t-r} \\int_r^t v(z_\\tau, \\tau), d\\tau$$\n通过 MeanFlow Identity 直接回归平均速度场，无需 ODE 求解； 训练目标为： $$L_{\\mathrm{cfg}} = \\left\\lVert u_\\theta - \\mathrm{sg}(u_{\\mathrm{target}}) \\right\\rVert^2$$\nDispersive Loss（正则项）\n$$L_{\\mathrm{disp}} = \\log \\mathbb{E}\\left[\\exp\\left(-\\frac{\\lVert z_i - z_j \\rVert^2}{\\tau}\\right)\\right]$$\n无正样本的对比损失； 训练时增强表征区分度，推理时不增加成本。 最终损失\n$$L_{\\mathrm{total}} = L_{\\mathrm{cfg}} + \\lambda \\cdot L_{\\mathrm{disp}}$$\n实验结果 仿真任务（Adroit + Meta-World，共 37 个任务）\n方法 NFE 平均成功率 平均推理时间 DP3 10 68.7% 132.2 ms FlowPolicy 1 71.6% 12.6 ms MP1 (ours) 1 78.9% 6.8 ms ✅ MP1 比 DP3 快 19×，比 FlowPolicy 快 2×，且成功率提升 7.3%。\n真实世界任务（ARX R5 双臂机器人）\n任务 MP1 成功率 完成时间 Hammer 90% 18.6s Drawer Close 100% 8.8s Heat Water 90% 23.4s Stack Block 80% 27.2s Spoon 90% 22.6s ✅ MP1 在所有任务中成功率最高，完成时间最短。\n数据需求 数据项 格式 说明 专家轨迹 每帧一条记录，包含：• 点云 P ∈ ℝ^(N×3)• 机器人状态 S ∈ ℝ^s（关节角/末端位姿）• 动作序列 A ∈ ℝ^(K×a) N=512/1024 点，K=4 步预测，a 为动作维度 训练集规模 10 条演示即可收敛，20 条以上收益递减 与 DP3 / FlowPolicy 设置一致 数据来源 仿真（Adroit、Meta-World）或真实机器人（ARX R5） 仿真用 Isaac Gym / MuJoCo，真实用 ROS 采集 资源需求 All training and testing are performed on an NVIDIA RTX4090 GPU,with a batch size of 128, optimization uses the AdamW optimizer with a learningrate of 0.0001 (Adroit and Meta-World apply the same learning rate), an observation window of 2steps, a history length of 4 states, and a prediction horizon of 4 steps.\nDreamVLA: A Vision-Language-Action Model Dreamed with Comprehensive World Knowledge website 标题跳动动画挺萌的 github刚刚开源一个月已经139stars arxiv\n典中典之先思考，用了 思考过程 不过如果迁移到自动驾驶，感觉不太适用。练这个需要的数据模态太多，耗费资源大，再加上我觉得它更擅长于处理静态的场景…\n这篇论文《DreamVLA: A Vision-Language-Action Model Dreamed with Comprehensive World Knowledge》提出了一种新型的机器人操作策略框架，旨在通过预测未来世界知识（如动态区域、深度图、语义信息）来增强机器人的感知-预测-行动闭环能力，从而提升其在复杂任务中的泛化性和推理能力。\n模型组件 模块 作用 World Knowledge Forecasting 预测未来关键信息：动态区域（哪里会动）、深度（3D结构）、语义（物体类别） Block-wise Attention 防止不同信息（动态、深度、语义）互相干扰，保持表示干净 Diffusion-based Action Head 用扩散模型从“世界知识”中解码出连续动作序列 端到端训练 统一训练视觉、语言、预测和动作，无需额外生成模型 模型改进 传统方法 DreamVLA 的改进 直接从图像+语言 → 动作，缺乏未来推理 先预测“未来世界状态”，再决定动作 预测整帧图像，冗余信息多 只预测关键区域（动态区域、深度、语义） 多模态信息混杂，互相干扰 用结构化注意力隔离不同信息 动作预测不稳定 用扩散模型生成平滑、物理合理的动作序列 实验结果 场景 结果 仿真 CALVIN 基准 平均任务长度 4.44（SOTA），优于 OpenVLA、GR-1 等方法 真实机器人（Franka 臂） 成功率 76.7%，显著高于 Diffusion Policy、OpenVLA 等基线 所需数据 📦 数据类型（多模态）\n模态 内容 格式 视觉 RGB 图像（静态摄像头 + 手腕摄像头） JPEG/PNG 深度 单目深度图（可选） PNG 或 NumPy 数组 语言 自然语言任务指令 JSON 或纯文本 动作 连续 7 维动作（6D 位移 + 夹爪状态） NumPy 数组 状态 机器人末端位姿 + 夹爪状态 NumPy 数组 辅助标签 动态区域掩码、SAM 分割、DINOv2 特征 NumPy 数组 数据来源与量级\n阶段 数据集 数据量 说明 预训练 DROID 7.6 万条机器人轨迹 多样化真实场景，Franka 机器人操作 预训练 CALVIN（无语言子集） 约 240 万步交互 仿真环境，长周期任务 微调 任务特定演示 每任务约 100 条轨迹 真实机器人任务，如拾取、放置、抽屉开关 训练流程 阶段 1：预训练\n目标：让模型学会从多模态输入中预测“未来世界知识”（动态区域、深度、语义）。 数据：DROID + CALVIN（无语言）。 监督信号： 动态区域：用 CoTracker 提取光流掩码 深度：Depth-Anything 伪标签 语义：DINOv2 + SAM 特征 训练设置： 优化器：AdamW，学习率 1e-3，余弦调度，5% 预热 批量大小：8（每 GPU）× 8 GPU = 64 训练轮数：20 epochs 损失权重： 动态区域：λ_dyn = 0.1 深度：λ_depth = 0.001 语义：λ_sem = 0.1 动作：λ_DiT = 1 阶段 2：微调\n目标：适应具体任务（如拾取、放置、抽屉操作）。 数据：每个任务约 100 条真实机器人演示。 训练方式： 继续使用预训练权重 只训练解码器和动作头，冻结部分主干（可选） 选择验证成功率最高的 checkpoint 作为最终模型 训练 DreamVLA 需用 DROID（7.6万条）+ CALVIN 预训练，再用每任务约 100 条真实演示微调，数据需包含 RGB、语言、动作、动态掩码、深度和语义特征，训练采用两阶段策略，耗时约 20 epochs，8×A800 GPU。\nTriVLA: A Triple-System-Based Unified Vision-Language-Action Model for General Robot Control arxiv website\n只有网站，还没有开源相关代码。这个多段其实比较符合我的想法，我觉得端到端直接来是真的不好搞啊。但是这个训练得实在是太耗资源了，要用视频模型预测未来动态场景，直接 8 个 H100 练 2-3 天，太凶猛了。我不看好用视频模型预测未来，没有必要。\n这篇论文《TriVLA: A Triple-System-Based Unified Vision-Language-Action Model for General Robot Control》提出了一种新的三系统统一架构，用于提升机器人在动态环境中执行长周期、复杂指令任务的能力。\n核心创新：三系统架构（Triple-System）\n系统编号 名称 作用 技术实现 System 2 Vision-Language Module 理解语言指令 + 场景语义 使用预训练 Eagle-2 VLM（SmolLM2 + SigLIP-2） System 3 Dynamics Perception Module 预测未来动态场景（视频级） 微调 Stable Video Diffusion（SVD）模型 System 1 Policy Learning Module 生成连续动作序列 使用 Diffusion Transformer + Flow Matching 解决的问题\n传统方法问题 TriVLA 如何解决 只看当前图像，忽略动态变化 System 3 预测未来帧，建模动态 缺乏语言与视觉的深度对齐 System 2 使用预训练 VLM 处理语言和图像 动作生成不连贯、频率低 System 1 使用扩散模型生成动作 chunk，支持 36Hz 控制频率 实验结果\n场景 数据集 表现 仿真 CALVIN ABC→D 平均任务长度 4.37（SOTA） 仿真 MetaWorld（60任务） 平均成功率 71.4%（优于 VPP、GR-1 等） 仿真 LIBERO（4套件） 在 Spatial/Object/Goal/Long 任务中均领先 真实机器人 Franka/Kinova/Fair 在少量演示下成功完成长周期任务 关键亮点\n数据效率高：仅用 10% CALVIN 数据，性能优于全数据训练的 GR-1。 控制频率高：36Hz 实时控制，优于传统扩散策略。 通用性强：支持不同机器人（Franka、Kinova、Fair）和多视角输入。 长周期任务能力强：可处理多步指令，如“打开抽屉→取出方块→放入盒子→关闭抽屉”。 所需数据 模态 内容 格式 视觉 多视角 RGB 图像（静态摄像头 + 手腕摄像头） PNG/JPEG 语言 自然语言任务指令 文本 动作 连续 7 维动作（末端位姿 + 夹爪状态） NumPy 数组 状态 机器人关节角度、末端位姿、速度等 NumPy 数组 视频 完整操作视频序列（用于 System 3） MP4 人类操作视频 互联网人类操作视频（用于预训练） MP4 辅助标签 可选：深度图、物体掩码、关键点等 NumPy 数组 数据类型 来源 量级 人类操作视频 Something-Something V2、YouTube 等 193,690 条 机器人操作视频 Open X-Embodiment、DROID、CALVIN 179,074 条 任务演示视频 CALVIN、MetaWorld、LIBERO、真实机器人 每任务 50–100 条 微调数据 真实机器人（Franka/Kinova/Fair） 每任务 100 条轨迹 三阶段训练流程 阶段 1：System 3 视频扩散模型微调（VDM）\n目标：让视频模型学会预测未来帧（动态感知） 数据： 人类操作视频（193k） 机器人操作视频（179k） 训练设置： 模型：Stable Video Diffusion（1.5B 参数） 损失：扩散重建损失 训练时间：2–3 天，8×H100 GPU 冻结参数：训练完成后冻结 System 3 阶段 2：System 1 策略网络训练（Policy Learning）\n目标：学习从视觉+语言+动态表示 → 动作的映射 数据： CALVIN、MetaWorld、LIBERO、真实机器人演示 训练设置： 模型：Diffusion Transformer（DiT） 损失：Flow Matching + MSE 动作损失 训练时间：5–9 小时，4×H100 GPU 控制频率：36 Hz 动作 chunk 长度：10 步 阶段 3：System 2 VLM 微调（可选）\n目标：增强语言理解能力（已在 Eagle-2 中预训练） 数据： 任务指令 + 图像对 训练设置： 模型：Eagle-2（SmolLM2 + SigLIP-2） 冻结主干，仅微调 LoRA 层 输入：224×224 图像 + 文本指令 输出：第 12 层 token（用于策略输入） Chain-of-Action: Trajectory Autoregressive Modeling for Robotic Manipulation Wenbo Zhang, Tianrun Hu, Yanyuan Qiao, Hanbo Zhang, Yuchu Qin, Yang Li, Jiajun Liu, Tao Kong, Lingqiao Liu, Xiao Ma\n主要是字节的工作\narxiv github (上个月开源, 54 stars)\n说是比 diffusion policy 要好, 真的假的\n这篇论文提出了一种新的机器人操作策略范式 —— Chain-of-Action（CoA），全称是“链式动作轨迹自回归建模”，用于解决传统机器人策略在长时任务中误差累积严重、空间泛化能力差的问题。\n📌 研究背景 传统方法的问题：大多数机器人策略采用“正向预测”方式，即根据当前观察逐步预测下一步动作。这种方式容易在长时间任务中累积误差，导致任务失败。 核心挑战：如何让机器人策略具备全局任务目标感知的推理能力，从而提高长时任务的成功率和空间泛化能力。 📌 核心创新：Chain-of-Action（CoA） CoA 的核心思想是反向推理动作序列：\n从任务目标（关键帧动作）出发，逆向生成整个动作轨迹。 这种“从目标倒推”的方式天然具有**全局到局部（global-to-local）**的结构，每一步动作都被最终目标所约束，从而显著减少误差累积。 📌 四大关键设计 为实现上述反向建模，CoA 引入了四项必要机制：\n设计组件 作用 连续动作表示 避免离散化带来的精度损失，适合精细控制。 多Token预测（MTP） 同时预测未来多个动作，增强局部一致性。 动态停止机制 根据当前状态与目标的接近程度自动决定轨迹长度。 反向时间集成（Reverse Temporal Ensemble） 多次反向生成轨迹并集成，提升鲁棒性。 📌 实验结果 ✅ 模拟环境（RLBench，60个任务）\nCoA 相比 ACT（Transformer策略）提升16.3%，相比 Diffusion Policy 提升23.2%。 在空间泛化能力上表现尤为突出，尤其在物体位置变化大的任务中优势明显。 ✅ 真实世界（8个厨房任务，Fetch机器人）\n成功率达 61.3%，明显高于 ACT（46.3%）和 Diffusion Policy（36.3%）。 验证了 CoA 在实际部署中的有效性。 训练过程分为 模拟实验（RLBench） 和 真实机器人实验 两部分。\n✅ 1. 模拟实验（RLBench）\n项目 说明 数据来源 RLBench 专家演示（Franka Panda 7-DoF 机器人，桌面任务） 数据内容 多视角 RGB 图像（128×128），夹爪状态，动作轨迹 数据量 每任务 100 条专家演示（仅使用 variation 0 以节省计算） 总任务数 60 个任务（对比 ACT/DP）；10 个任务（对比 Octo） 总数据量 约 6,000 条演示（60×100） 计算资源 1× NVIDIA H100 GPU（单卡） 训练时间 20,000 步，batch size = 128，约 1～2 天 网络结构 ResNet-18 + 4层 Transformer Encoder + 7层 Transformer Decoder ✅ 2. 真实机器人实验（Fetch 机器人）\n项目 说明 数据来源 8 个厨房操作任务（如开抽屉、放杯子、关微波炉等） 数据内容 单视角 RGB（640×480 → 224×224），夹爪状态，动作轨迹 数据量 每任务 35～81 条专家演示 总数据量 约 400～600 条演示（8×50 平均值） 计算资源 1× NVIDIA RTX 4070 Laptop GPU（实时推理） 训练时间 与模拟设置一致，约 1～2 天 推理频率 策略 10Hz，PD 控制器 1000Hz ✅ 总结表格\n场景 数据量（每任务） 总数据量 计算资源 训练时间 RLBench 模拟 100 条 ~6,000 条 1× H100 ~1–2 天 真实机器人 35–81 条 ~500 条 1× 4070 Laptop ~1–2 天 CoA 每任务仅需几十到上百条专家演示，单张 GPU（H100 或 4070）即可在 1～2 天内完成训练，资源需求远低于视频生成类方法。\nChain-of-Action 通过“从目标倒推”的反向动作建模方式，显著提升了机器人策略在长时、复杂任务中的鲁棒性和泛化能力，是一种新的、有前景的机器人动作建模范式。\nEfficient Robotic Policy Learning via Latent Space Backward Planning Dongxiu Liu, Haoyi Niu, Zhihao Wang, Jinliang Zheng, Yinan Zheng, Zhonghong Ou, Jianming Hu, Jianxiong Li, Xianyuan Zhan\narxiv website\n主页不错, 可以fork. 非常神秘, 和coa一样, 这一篇也是反向操作. 不过训练耗费资源还是相当大的.\n这篇文章提出了一种高效、鲁棒的机器人长时任务规划框架，名为 LBP（Latent Space Backward Planning），核心思想是：\n“从最终目标出发，反向递归地规划中间子目标，从而在长时任务中实现高效、准确、任务一致的规划。”\n研究背景与问题 当前机器人规划方法面临一个“效率-精度-一致性”三难困境：\n方法类型 优点 缺点 细粒度视频预测（如UniPi、GR-1） 提供丰富未来信息 计算昂贵、误差累积严重 粗粒度子目标规划（如GCSL、SuSIE） 计算轻量 正向规划容易偏离最终目标，导致“跑题” 📌 LBP 的核心创新 ✅ 1. 潜空间建模（Latent Space）\n不在像素空间做规划，而是在视觉潜空间（如DecisionNCE、SigLIP）中进行，大幅降低计算量。 通过潜空间保留语义信息，同时避免高维图像带来的冗余。 ✅ 2. 反向规划（Backward Planning）\n从最终目标出发，递归地生成中间子目标，逐步靠近当前状态。 每一步子目标都与最终目标对齐，避免“跑偏”。 ✅ 3. 子目标融合（Goal-Fusion Attention）\n使用 Perceiver-style Cross-Attention 动态融合不同距离的子目标信息。 让策略在不同阶段自适应地关注短期 vs 长期信息。 步骤 说明 Step 1：目标生成 根据当前图像 + 语言指令，预测最终潜空间目标（latent goal） Step 2：子目标反向生成 从目标开始，递归生成中间子目标（由远到近） Step 3：策略执行 用子目标序列作为上下文，训练或引导策略执行动作 📌 实验结果 ✅ LIBERO-LONG 模拟基准（10个长时任务）\n方法 平均成功率 LBP（DecisionNCE） 88.6% ✅ Seer 78.6% SuSIE 76.3% OpenVLA 54.0% LBP 显著优于所有基线，尤其在多阶段任务中表现突出。\n✅ 真实机器人实验（4个长时任务）\n任务 阶段数 LBP 平均得分 Move cups 2 77.9 ✅ Stack 4 cups 3 72.5 ✅ Shift cups 5 67.1 ✅ LBP 在后期阶段优势显著，说明其长时一致性更好。 LBP 用“从终点倒推”的方式，在潜空间中轻量、准确地规划子目标，显著提升了机器人长时任务的成功率和泛化能力。\n训练过程 ✅ 1. 高层规划器（High-Level Planner）\n负责生成最终目标（latent goal）和子目标（subgoals）\n项目 说明 所需数据 专家演示视频（含图像 + 语言指令 + 动作） 数据量 每个任务 50条专家演示（LIBERO-LONG）每个真实任务 200条专家演示 数据格式 图像（多视角）、语言指令、动作序列 计算资源 1× NVIDIA H100 GPU训练 100k steps，batch size = 64 训练时间 约 2~3天（单卡） ✅ 2. 低层策略（Low-Level Policy）\n根据子目标序列执行动作\n项目 说明 所需数据 与高层共用（专家演示） 数据量 同上（50/200条） 计算资源 1× NVIDIA H100 GPU（模拟）1× NVIDIA 4070 Laptop GPU（真实机器人） 训练时间 模拟：200k steps（约34天）真实机器人：400k steps（约56天） 模块 数据量（每任务） 计算资源 训练时间（单卡） 高层规划器 50（模拟）/ 200（真实） 1× H100 23天 低层策略 同上 1× H100（模拟）/ 4070（真实） 3~6天 每任务只需几十到几百条专家演示视频，单张GPU即可在几天内完成训练，资源门槛远低于视频生成类方法。\n如需更低资源版本（如更少数据或更小模型），作者也指出LBP支持灵活压缩子目标数量（如只预测2~3个），可进一步降低训练成本。\n场景重建 四维重建要在三维基础上再加时间，有点猛了\nStreamVGGT: Streaming 4D Visual Geometry Transformer Dong Zhuo*, Wenzhao Zheng*, †, Jiahe Guo, Yuqi Wu, Jie Zhou, Jiwen Lu\n清华的工作，500 stars\nwebsite arxiv github\nStreamVGGT 是一个基于因果 Transformer 的实时 4D 视觉几何重建模型，支持\n“逐帧增量更新 + 缓存历史 token 记忆”，在保持 VGGT 级精度的同时实现低延迟在线推理。\n4D 重建：从视频中恢复动态 3D 场景 + 时间维度，是 CV 的基础任务。 现有问题： 离线模型（如 VGGT、Fast3R）每次都要重新处理整个序列，无法实时； 流式模型（如 Spann3R、CUT3R）虽支持在线更新，但存在误差累积； 效率瓶颈：全局注意力复杂度高，不适合长序列。 模型结构\n模块 设计 作用 因果 Transformer 仅允许当前帧关注历史帧，模拟“人类感知” 保证因果性，减少计算 Cached Token Memory 缓存历史帧的 key/value token，避免重复计算 实现“增量更新” 知识蒸馏 用 VGGT（全局注意力）作为教师，蒸馏到因果学生模型 抑制误差累积，提升精度 FlashAttention-2 集成高效注意力算子 实现实时推理 模块 说明 Image Encoder 使用 DINOv2 提取图像 token Spatio-Temporal Decoder 替换 VGGT 的全局注意力为时间因果注意力 Cached Memory 缓存历史 token，推理时只处理当前帧 Multi-Task Heads 同时输出：• 相机位姿（pose）• 深度图（depth）• 点云图（point map）• 2D 点追踪（tracking） 实验结果\n任务 数据集 对比模型 结果 3D 重建 7-Scenes / NRGBD / ETH3D vs CUT3R、Spann3R 优于 SOTA 流式模型，接近 VGGT 单帧深度估计 KITTI / Sintel / NYU-v2 vs MonST3R、DUSt3R 优于所有流式模型 视频深度估计 Sintel / Bonn / KITTI vs CUT3R、Point3R 优于 CUT3R 相机位姿估计 CO3Dv2 vs VGGT AUC@30 达到 82.4（接近 VGGT 87.7） 推理效率\n帧数 VGGT（全局） StreamVGGT（流式） N=1 2089 ms 386 ms N=10 2000 ms 67 ms N=40 2089 ms 68 ms ✅ StreamVGGT 在长序列下推理时间几乎恒定，VGGT 随帧数线性增长。\n局限性\n问题 说明 内存膨胀 缓存 token 随帧数线性增长，不适合超长序列 教师模型限制 蒸馏依赖 VGGT，极端场景（高速、非刚性）表现下降 部署限制 当前模型较大，不适合移动端 视频生成 StreamDiT: Real-Time Streaming Text-to-Video Generation Akio Kodaira, Tingbo Hou, Ji Hou, Masayoshi Tomizuka, Yue Zhao\nUC Berkeley, Meta\narxiv website\n囤在这里,虽然不做视频生成,但是还是要看\n这篇文章提出了一种名为 StreamDiT 的新型实时流式文本到视频生成模型，旨在解决现有视频生成模型只能离线生成长度有限、短时视频片段的问题。文章的核心贡献和创新点可以总结为以下几点：\n研究背景与问题 现有问题：虽然基于扩散变换器（DiT）的文本到视频（T2V）模型在视频质量上取得了显著进展，但它们通常只能离线生成短片段，难以满足实时、交互式应用的需求。 关键挑战：如何在保证视频内容一致性和高质量的前提下，实现流式、实时、长视频的生成。 核心贡献 提出 StreamDiT 训练框架 基于流匹配（Flow Matching） 的训练方法，引入了一个滑动缓冲区（moving buffer） 来处理视频帧序列。 统一的分区策略（partitioning scheme）：将缓冲区中的帧划分为多个“块”（chunks），每个块包含多个帧和微步（micro-steps），从而统一了传统扩散模型中的均匀噪声和FIFO-Diffusion中的对角线噪声方法。 混合训练策略：在训练中同时使用多种分区方案（如不同的块大小和步数），增强了模型的泛化能力，避免了过拟合某一特定方案。 设计 高效的 StreamDiT 模型架构 基于 adaLN DiT（自适应层归一化的扩散变换器），引入了可变时间嵌入（varying time embedding） 和窗口注意力（window attention），以提升效率并适应流式生成。 模型规模：训练了一个 40 亿参数（4B）的模型，能够在单张 H100 GPU 上实现 16FPS 的实时生成。 提出 多步蒸馏（Multistep Distillation）方法 针对 StreamDiT 的特殊分区设计，定制了蒸馏策略，将原本需要 128 步的去噪过程压缩到 8 步，同时不依赖无分类器引导（CFG），实现了实时推理。 实验 与现有方法对比：在 VBench 和人类评估中，StreamDiT 在长视频生成的质量、一致性、动态性等方面均优于 ReuseDiffuse 和 FIFO-Diffusion 等现有流式生成方法。 消融实验：验证了混合训练策略的有效性，表明混合不同分区方案能提升生成质量。 应用场景： 实时流式生成：可实时生成长达 1 分钟以上的视频。 交互式生成：用户可实时输入提示词，动态改变视频内容。 视频到视频编辑：支持实时视频编辑任务（如将视频中的猪变成猫）。 StreamDiT 提出了一种新颖的流式文本到视频生成框架，通过创新的训练策略、高效模型架构和定制蒸馏方法，首次实现了在单张 GPU 上的实时、高质量、长视频生成，为交互式视频应用开辟了新可能。\n其他 DenseMixer: Improving MoE Post-Training with Precise Router Gradient Feng Yao$^{\\star\\dagger}$ Junxia Cui$^{\\star}$ Ruohan Zhang$^{\\star}$ Liyuan Liu$^{\\dagger}$ Shibo Hao Li Zhang Chengyu Dong Shuohang Wang Yelong Shen Jianfeng Gao Jingbo Shang\n$^{\\dagger}$: Project Lead; $^{\\star}$: Core Contributors; (Work in Progress)\nUCSD, Microsoft\nblog github 两个月前开源，star 58\nMoE 的优化工作\n这篇文章主要介绍了一个新方法 DenseMixer，旨在改进 Mixture-of-Experts（MoE） 模型的后训练（post‑training）效果。核心内容如下：\n研究背景与现有挑战 MoE 模型相比稠密模型来说训练更困难，关键问题源于其稀疏路由机制（Top‑K router），该机制非可微，导致梯度反向传播复杂。\nDenseMixer 方法 论文提出了 DenseMixer 技术，通过在前向传播时对所有专家（包括未激活的专家）进行计算，来获取更加精确的路由梯度。它通过多付出一次前向计算的代价，换取更优的梯度估计。\n适应性强，使用简单\n兼容性广：支持不同规模的 MoE（如 7B、14B、30B）、架构（是否共享专家）、预训练方式（从零开始或 “up‑cycling”）、以及不同后训练数据类型（如 instruction tuning 或 long chain-of-thought 数据）。 方便使用：只需执行 pip install densemixer 然后 densemixer setup，设置环境变量 DENSEMIXER_ENABLED=1 即可启用 DenseMixer，无需代码更改、推理无额外开销。 实验表现优异 在多个任务的多种模型规模下，DenseMixer 均显著优于传统方法，平均提升一般在 2% 左右，在某些评测上甚至更高。\n总结来说，这篇文章提出的 DenseMixer 是一种简单易用、兼容性强且效果可靠的 MoE 后训练方案，通过改善梯度估计质量来提升模型表现。\n","wordCount":"3574","inLanguage":"en","image":"https://MeteorCollector.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-08-03T00:00:00Z","dateModified":"2025-08-03T00:00:00Z","author":[{"@type":"Person","name":"MeteorCollector"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://MeteorCollector.github.io/posts/vla-rl-0803/"},"publisher":{"@type":"Organization","name":"MeteorCollectorBlogs","logo":{"@type":"ImageObject","url":"https://MeteorCollector.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://MeteorCollector.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://MeteorCollector.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://MeteorCollector.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://MeteorCollector.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://MeteorCollector.github.io title=Github><span>Github</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://MeteorCollector.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://MeteorCollector.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">VLA RL Aug '25 A</h1><div class=post-description>八月上旬看的文章放到这里</div><div class=post-meta><span title='2025-08-03 00:00:00 +0000 UTC'>August 3, 2025</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;3574 words&nbsp;·&nbsp;MeteorCollector</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#diffusion>Diffusion</a><ul><li><a href=#diwa-diffusion-policy-adaptation-with-world-models>DiWA: Diffusion Policy Adaptation with World Models</a></li><li><a href=#reinforcement-learning-for-flow-matching-policies>Reinforcement Learning for Flow-Matching Policies</a></li><li><a href=#transition-matching-scalable-and-flexible-generative-modeling>Transition Matching: Scalable and Flexible Generative Modeling</a></li><li><a href=#steering-your-diffusion-policy-with-latent-space-reinforcement-learning>Steering Your Diffusion Policy with Latent Space Reinforcement Learning</a></li><li><a href=#hierarchical-rectified-flow-matching-with-mini-batch-couplings>Hierarchical Rectified Flow Matching with Mini-Batch Couplings</a></li></ul></li><li><a href=#rl4ad>RL4AD</a><ul><li><a href=#carl-learning-scalable-planning-policies-with-simple-rewards>CaRL: Learning Scalable Planning Policies with Simple Rewards</a></li><li><a href=#action-space-reduction-strategies-for-reinforcement-learning-in-autonomous-driving>Action Space Reduction Strategies for Reinforcement Learning in Autonomous Driving</a></li><li><a href=#reinforcement-learning-with-action-chunking>Reinforcement Learning with Action Chunking</a></li><li><a href=#breaking-imitation-bottlenecks-reinforced-diffusion-powers-diverse-trajectory-generation>Breaking Imitation Bottlenecks: Reinforced Diffusion Powers Diverse Trajectory Generation</a></li><li><a href=#dyna-reinforcement-learning-in-real-world>DYNA: Reinforcement Learning in Real World</a></li></ul></li><li><a href=#vla>VLA</a><ul><li><a href=#fedvla-federated-vision-language-action-learning-with-dual-gating-mixture-of-experts-for-robotic-manipulation>FedVLA: Federated Vision-Language-Action Learning with Dual Gating Mixture-of-Experts for Robotic Manipulation</a></li><li><a href=#vote-vision-language-action-optimization-with-trajectory-ensemble-voting>VOTE: Vision-Language-Action Optimization with Trajectory Ensemble Voting</a></li><li><a href=#video-generators-are-robot-policies>Video Generators are Robot Policies</a></li><li><a href=#pre-training-auto-regressive-robotic-models-with-4d-representations>Pre-training Auto-regressive Robotic Models with 4D Representations</a></li><li><a href=#mp1-meanflow-tames-policy-learning-in-1-step-for-robotic-manipulation>MP1: MeanFlow Tames Policy Learning in 1-step for Robotic Manipulation</a></li><li><a href=#dreamvla-a-vision-language-action-model-dreamed-with-comprehensive-world-knowledge>DreamVLA: A Vision-Language-Action Model Dreamed with Comprehensive World Knowledge</a></li><li><a href=#trivla-a-triple-system-based-unified-vision-language-action-model-for-general-robot-control>TriVLA: A Triple-System-Based Unified Vision-Language-Action Model for General Robot Control</a></li><li><a href=#chain-of-action-trajectory-autoregressive-modeling-for-robotic-manipulation>Chain-of-Action: Trajectory Autoregressive Modeling for Robotic Manipulation</a></li><li><a href=#efficient-robotic-policy-learning-via-latent-space-backward-planning>Efficient Robotic Policy Learning via Latent Space Backward Planning</a></li></ul></li><li><a href=#场景重建>场景重建</a><ul><li><a href=#streamvggt-streaming-4d-visual-geometry-transformer>StreamVGGT: Streaming 4D Visual Geometry Transformer</a></li></ul></li><li><a href=#视频生成>视频生成</a><ul><li><a href=#streamdit-real-time-streaming-text-to-video-generation>StreamDiT: Real-Time Streaming Text-to-Video Generation</a></li></ul></li><li><a href=#其他>其他</a><ul><li><a href=#densemixer-improving-moe-post-training-with-precise-router-gradient>DenseMixer: Improving MoE Post-Training with Precise Router Gradient</a></li></ul></li></ul></nav></div></details></div><div class=post-content><blockquote><p>本篇从老站点迁移而来，公式可能不太舒服，见谅</p></blockquote><h1 id=b2dvl完事了看看最近的论文>B2DVL完事了，看看最近的论文<a hidden class=anchor aria-hidden=true href=#b2dvl完事了看看最近的论文>#</a></h1><blockquote><p>一般来讲，越靠上的越新</p></blockquote><h2 id=diffusion>Diffusion<a hidden class=anchor aria-hidden=true href=#diffusion>#</a></h2><h3 id=diwa-diffusion-policy-adaptation-with-world-models>DiWA: Diffusion Policy Adaptation with World Models<a hidden class=anchor aria-hidden=true href=#diwa-diffusion-policy-adaptation-with-world-models>#</a></h3><p>Akshay L Chandra1∗, Iman Nematollahi1∗, Chenguang Huang2 Tim Welschehold1, Wolfram Burgard2, Abhinav Valada1 1 University of Freiburg 2 University of Technology Nuremberg</p><p><a href=https://arxiv.org/abs/2508.03645>arxiv</a> <a href=https://github.com/acl21/diwa>github (2~3个月之前开源, 23 stars)</a> <a href=https://diwa.cs.uni-freiburg.de/>website</a></p><p>这篇论文叫 <strong>《DiWA: Diffusion Policy Adaptation with World Models》</strong>，它提出了一种全新的方法，<strong>让机器人可以在完全不接触真实环境的情况下，通过“想象”来提升已有的技能</strong>，尤其适用于<strong>基于扩散模型（Diffusion Policy）的机器人控制策略</strong>。</p><blockquote><p>DiWA 是第一个<strong>完全离线</strong>的扩散策略微调框架，它用一个<strong>世界模型</strong>代替真实环境，让机器人通过“在脑子里练”来提升技能，<strong>不需要任何额外真实交互</strong>，却比传统在线强化学习方法更高效、更安全。</p></blockquote><h4 id=diwa-的核心思路>DiWA 的核心思路<a hidden class=anchor aria-hidden=true href=#diwa-的核心思路>#</a></h4><table><thead><tr><th>阶段</th><th>任务</th><th>方法</th></tr></thead><tbody><tr><td><strong>1. 世界模型训练</strong></td><td>学会“想象”</td><td>用大量<strong>无标签的机器人自由探索数据</strong>训练一个<strong>世界模型</strong>，能预测未来状态</td></tr><tr><td><strong>2. 策略预训练</strong></td><td>学会“模仿”</td><td>用少量专家演示数据预训练一个<strong>扩散策略</strong>（Diffusion Policy）</td></tr><tr><td><strong>3. 奖励建模</strong></td><td>学会“目标”</td><td>用专家数据训练一个<strong>奖励分类器</strong>，判断某个状态是否接近任务成功</td></tr><tr><td><strong>4. 离线微调</strong></td><td>学会“改进”</td><td>在<strong>世界模型里做强化学习（PPO）</strong>，通过“想象的轨迹”来微调策略</td></tr></tbody></table><h4 id=实验结果>实验结果<a hidden class=anchor aria-hidden=true href=#实验结果>#</a></h4><p><strong>✅ 模拟环境（CALVIN benchmark）</strong></p><table><thead><tr><th>方法</th><th>成功率</th><th>是否在线交互</th><th>交互次数</th></tr></thead><tbody><tr><td>原始扩散策略</td><td>57.8%</td><td>❌</td><td>0</td></tr><tr><td><strong>DiWA</strong>（离线微调）</td><td><strong>82.3%</strong></td><td>❌</td><td><strong>0</strong></td></tr><tr><td>DPPO（在线微调）</td><td>82.3%</td><td>✅</td><td><strong>250万次</strong></td></tr></tbody></table><p><strong>✅ 真实世界（Franka机器人）</strong></p><table><thead><tr><th>任务</th><th>原始策略</th><th>DiWA微调后</th></tr></thead><tbody><tr><td>打开抽屉</td><td>55% → <strong>85%</strong></td><td></td></tr><tr><td>关闭抽屉</td><td>60% → <strong>95%</strong></td><td></td></tr><tr><td>推滑块</td><td>55% → <strong>87%</strong></td><td></td></tr></tbody></table><h4 id=技术亮点>技术亮点<a hidden class=anchor aria-hidden=true href=#技术亮点>#</a></h4><table><thead><tr><th>模块</th><th>作用</th><th>技术细节</th></tr></thead><tbody><tr><td><strong>Dream Diffusion MDP</strong></td><td>把扩散过程建模为强化学习问题</td><td>把每一步“去噪”看作一个动作，整个世界模型作为环境</td></tr><tr><td><strong>世界模型（World Model）</strong></td><td>替代真实环境</td><td>基于DreamerV2架构，支持长时序预测</td></tr><tr><td><strong>奖励分类器</strong></td><td>代替真实奖励</td><td>用专家数据训练一个二分类器，判断状态是否成功</td></tr><tr><td><strong>行为克隆正则化</strong></td><td>防止“钻空子”</td><td>限制策略不要太偏离原始行为，避免利用世界模型的缺陷</td></tr></tbody></table><h3 id=reinforcement-learning-for-flow-matching-policies>Reinforcement Learning for Flow-Matching Policies<a hidden class=anchor aria-hidden=true href=#reinforcement-learning-for-flow-matching-policies>#</a></h3><p>Samuel Pfrommer, Yixiao Huang, Somayeh Sojoudi（UC Berkeley）<br>arXiv:2507.15073v1 [cs.LG] 20 Jul 2025 <a href=https://arxiv.org/abs/2507.15073>Reinforcement Learning for Flow-Matching Policies</a></p><p>这个论文到现在两个月了，github repo 仅有 4 star，难说靠不靠谱。看起来就是给 flow matching 上了 GRPO 来试试效果。</p><p>本文首次系统地把强化学习（RL）用于“流匹配（flow-matching）”策略的二次优化，使其能够超越次优演示数据，并支持可变时域的最短时间控制；提出了两种方法——RWFM（加权模仿）与 GRPO（组相对策略优化），在仿真独轮车任务上将演示策略成本降低 50–85%。</p><ol><li>研究背景<br>• 现代通才机器人策略（VLA 模型，如 π0、RT-2、Octo）普遍采用“流匹配 / 扩散”动作专家，通过模仿学习一次性生成固定长度动作块。<br>• 但人类演示存在两类次优：<br>– 变异性次优（variation suboptimality）：同一指令下动作优劣不一。<br>– 支撑集次优（support suboptimality）：演示未覆盖更优动作轨迹。<br>• 固定长度动作块也无法实现“尽快完成任务”的最短时间目标。</li><li>主要贡献<br>(1) 形式化流匹配策略的 RL 问题，指出需同时解决上述两类次优。<br>(2) 在流匹配框架中引入“时域通道”，让模型可生成任意长度的动作轨迹，实现可变时域规划。<br>(3) 提出两种 RL 微调方法：<br>• RWFM（Reward-Weighted Flow Matching）：在模仿损失中用指数奖励加权，并加入高斯“bump”探索噪声，使策略逐渐偏向高奖励轨迹并突破演示支撑集。<br>• GRPO（Group Relative Policy Optimization）：<br>– 采用免价值函数的 PPO 变体 GRPO，提升样本效率；<br>– 训练一个轻量级奖励代理 $( R_\varphi(\tilde{o}, A) )$
，在无需真实 rollout 的情况下即可估计动作块奖励；<br>– 组内相对优势计算 + 加权流匹配损失，显著减少与环境交互次数。<br>(4) 在 6 种奖励设定（位置、时间、速度、碰撞、朝向、控制正则）的 2D 独轮车环境上验证：<br>• 纯模仿（ILFM）只能复现演示水平；<br>• RWFM 显著提升，但仍受限于在线 rollout 成本；<br>• GRPO 用更少交互量达到最佳，平均成本比 ILFM 低 50–85%。<br>(5) 消融实验显示：<br>• 奖励缩放 $\alpha$ 过大易导致策略忽视观测条件；<br>• 动作探索幅度 $M \approx 0.2$ 对突破支撑集最有效，能让策略学会演示中未出现的“刹车”行为。</li><li>方法要点<br>• 可变时域：把原始轨迹插值到统一长度 $H^\prime$，并拼接“期望时域”额外通道；生成时再反推真实步数。<br>• RWFM：在演示数据上按 $\mathrm{e}^{\alpha R}$ 加权做流匹配，随后用当前策略收集高奖励轨迹继续训练。<br>• GRPO：<br>– 预训练阶段先用演示数据训练奖励代理 $R_\varphi$（TimesNet 架构）。<br>– 每轮采样 G=10 条动作块，用 $R_\varphi$ 计算组内优势，加权更新流匹配网络。<br>– 仅在验证性能停滞时才进行真实环境的少量 rollout，以校正奖励代理。</li></ol><h3 id=transition-matching-scalable-and-flexible-generative-modeling>Transition Matching: Scalable and Flexible Generative Modeling<a hidden class=anchor aria-hidden=true href=#transition-matching-scalable-and-flexible-generative-modeling>#</a></h3><p>Meta</p><p>Flow Matching 的改进，<a href=https://arxiv.org/abs/2506.23589>airxiv</a></p><p>这篇文章的话，已经有珠玉在前。有一篇讲 transition matching 的知乎文章，顺带讲了一些 flow matching 的原理： <a href=https://zhuanlan.zhihu.com/p/1928847692173390104>Transition Matching: Scalable and Flexible Generative Modeling （公式看晕了，喂！） - 知乎</a></p><p>另外记一下 velocity：</p><p>在 <strong>Flow Matching</strong> 中，<strong>velocity（速度场）</strong> 是一个向量场，描述了如何从噪声（源分布）一步步“流动”到真实数据（目标分布）。</p><p>在 Flow Matching 中，我们假设：</p><ul><li>有一个<strong>源分布</strong> $p_0(x)$（通常是标准高斯）；</li><li>有一个<strong>目标分布</strong> $p_1(x)$（真实数据分布）；</li><li>我们希望构造一条<strong>连续的路径</strong>（flow），把 $p_0$ 变成 $p_1$。</li></ul><p>这个路径是通过一个**常微分方程（ODE）**来定义的：</p><p>$$
\frac{dx_t}{dt} = v(x_t, t), \quad t \in [0, 1]
$$</p><p>其中：</p><ul><li>$x_t$ 是时间 $t$ 时的中间状态；</li><li>$v(x_t, t)$ 就是所谓的 <strong>velocity field（速度场）</strong>，它告诉我们在每个位置 $x_t$ 和时间 $t$ 应该朝哪个方向“移动”。</li></ul><p>假设现在有一个点 $x_0$ 从标准高斯采样出来，目标是变成一张猫的图片 $x_1$。</p><ul><li><p><strong>velocity $v(x_t, t)$</strong> 就是每一步告诉你：</p><blockquote><p>“你现在在这个位置 $x_t$，下一步应该往哪个方向走，才能更接近真实的猫图？”</p></blockquote></li></ul><p>这个速度场是用一个神经网络 $v_\theta(x_t, t)$ 来学习的。</p><table><thead><tr><th>方法</th><th>如何移动</th></tr></thead><tbody><tr><td><strong>扩散模型（Diffusion）</strong></td><td>通过加噪/去噪，每一步是随机扰动（SDE）</td></tr><tr><td><strong>Flow Matching</strong></td><td>通过确定性速度场，每一步是<strong>直接移动</strong>（ODE）</td></tr></tbody></table><h3 id=steering-your-diffusion-policy-with-latent-space-reinforcement-learning>Steering Your Diffusion Policy with Latent Space Reinforcement Learning<a hidden class=anchor aria-hidden=true href=#steering-your-diffusion-policy-with-latent-space-reinforcement-learning>#</a></h3><p>Wagenmaker 等，UC Berkeley & UW</p><p>arXiv:2506.15799v2 [cs.RO] 25 Jun 2025 <a href=https://arxiv.org/abs/2506.15799v2>arxiv</a> <a href=https://diffusion-steering.github.io/>github</a></p><p>一句话总结
DSRL 把 RL 的作用域从“改权重”变成了“改噪声”：在保持预训练扩散/流匹配策略权重冻结的前提下，仅在其输入噪声空间里学一个小策略，就能在极少交互下把成功率从 20 % 提到 90 %，并首次实现了 π0 这类 3.3 B 通用机器人策略的在线 RL 微调。</p><p><strong>1. 研究动机</strong></p><ul><li>行为克隆（<strong>BC</strong>）+ 扩散策略（$\pi_{\mathrm{dp}}$）已成为通才机器人控制的主流，但遇到新场景往往表现不佳。</li><li>传统 RL 微调需更新大模型权重，代价高且不稳定；后处理动作或残差策略又效率低。</li><li>关键观察：扩散模型是 “给定初始噪声 $\rightarrow$ 确定性去噪 $\rightarrow$ 动作” 的映射，因此只需控制噪声即可控制动作。</li></ul><p><strong>2. 核心思路：Diffusion Steering via RL (DSRL)</strong></p><ul><li>把原 MDP 重写成 “噪声-动作” MDP $M^w$：<br>状态 $s ;\to;$ 选噪声 $w ;\to; \pi_{\mathrm{dp}}(s,w)$ 输出动作 $a$。</li><li>在 $M^w$ 上用任意 RL 算法学一个小策略 $\pi_w(s) \to w$，完全不碰 $\pi_{\mathrm{dp}}$ 权重。</li><li>好处：<ul><li>黑盒、无需反向传播多步去噪链；</li><li>参数量缩小几个数量级，可在真实机器人 1 GPU 上在线训练；</li><li>即插即用，适用于扩散/流匹配、DDIM/DDPM、专有或开源大模型。</li></ul></li></ul><p><strong>3. 方法细节</strong></p><p>(1) 噪声别名 (Noise Aliasing) 技巧</p><ul><li>同一动作可能由不同 $w$ 得到，利用这一点把离线数据转成 $w$-Q 值，提升样本效率；</li><li>提出 <strong>DSRL-NA</strong>：两个 critic（$Q_A$ 在动作空间，$Q_W$ 在噪声空间），$Q_W$ 通过 $Q_A$ 蒸馏 + 别名映射，实现离线/在线统一。</li></ul><p>(2) 训练流程
– 预训练 πdp（冻结）→ 在噪声空间初始化 π_w、Q_w → 在线/离线 RL 更新 π_w。
– 仅需前向推理 πdp，无需梯度回传。</p><ol><li>实验亮点
• 在线适应：在 Robomimic、OpenAI Gym、真实 Franka / WidowX 上，DSRL 用 5–10× 更少交互即可超过 DPPO、IDQL 等最新方法。
• 离线适应：在 10 个 OGBench 任务中，DSRL 有一半任务是 SoTA，且只需用同一份离线数据。
• 真实世界：
– 单任务 Cube→Bowl：BC 20 % → DSRL 90 %（&lt;50 回合）。
– 多任务 Bridge-V2 预训练：DSRL 在 100–150 回合内显著改善抽屉、堆叠等任务。
– π0（3.3 B）微调：Libero 任务 20 %→100 %（∼1 万步），Aloha 双手机器人任务显著超越 RESIP/V-GPS；首次在真实 Franka 上成功微调 π0。</li><li>消融与洞察
• 噪声别名可把在线样本效率再提高 2×。
• 即使 πdp 训练数据质量差、过拟合或网络小，DSRL 仍能快速“拉回”性能。
• 去噪步数、网络规模对 DSRL 几乎无影响；限制噪声幅值 $b_w \in [1,3]$ 即可保证稳定性。</li><li>局限与未来方向
• 若 πdp 动作分布极度集中，可能无法提供足够可操纵的噪声空间；
• 仍需奖励设计与环境重置；
• 未来可探索：
– 将“噪声”拓展到 prompt / 观测空间；
– 理论刻画噪声空间表达能力；
– 无奖励或自动奖励设定。</li></ol><p>DSRL 把“微调大模型”变成“微调小噪声”，让真实机器人用几十次交互就能把 20 % 成功率飙到 90 %，并首次把 RL 成功塞进 3.3 B 参数的通用策略 π0，为现场自适应打开了实用大门。</p><h3 id=hierarchical-rectified-flow-matching-with-mini-batch-couplings>Hierarchical Rectified Flow Matching with Mini-Batch Couplings<a hidden class=anchor aria-hidden=true href=#hierarchical-rectified-flow-matching-with-mini-batch-couplings>#</a></h3><p><a href=https://github.com/riccizz/HRF_coupling>github repo</a> 还没开源而且仅有一个 star。</p><p>Yichi Zhang, Yici Yan, Alex Schwing, Zhizhen Zhao<br>University of Illinois Urbana-Champaign</p><p>提出了一种<strong>改进的流匹配方法（HRF）</strong>，通过<strong>小批量最优传输（mini-batch optimal transport）<strong>来</strong>简化速度场的多模态分布</strong>，从而提升生成质量和效率，尤其适用于<strong>低计算预算（低NFE）场景</strong>。</p><p><strong>流匹配（Flow Matching）</strong> 是一种生成模型方法，通过建模一个<strong>速度场（velocity field）</strong> 来将简单分布（如高斯）转换成复杂数据分布。它通过数值积分一个常微分方程（ODE）来生成样本。</p><p>但传统流匹配存在两个问题：</p><ol><li><strong>速度场是多模态的</strong>，难以建模；</li><li><strong>路径弯曲</strong>，导致采样效率低。</li></ol><p><strong>层次流匹配（Hierarchical Rectified Flow, HRF）</strong> 被提出用于建模速度场的分布，但它在每一层的复杂度都很高，<strong>没有简化建模过程</strong>。</p><p>作者提出：<strong>通过小批量耦合（mini-batch couplings）来逐步简化速度场的复杂度</strong>，从而改善生成质量和效率。具体包括：</p><p><strong>数据空间耦合（Data Coupling）</strong></p><ul><li>不再独立采样源分布和数据点，而是<strong>用小批量最优传输（mini-batch OT）来配对样本</strong>。</li><li>结果：速度场分布变得更<strong>单峰（unimodal）</strong>，更容易学习。</li></ul><p><strong>速度空间耦合（Velocity Coupling）</strong></p><ul><li>在速度空间中，也用小批量OT来配对初始速度 $v_0$ 和目标速度 $v_1$。</li><li>结果：采样路径更直，<strong>减少积分步数（NFE）</strong>，尤其适用于<strong>低预算采样</strong>。</li></ul><p><strong>联合耦合（Data + Velocity Coupling）</strong></p><ul><li>两阶段训练：先用数据耦合训练，再用速度耦合微调。</li><li>结果：在低NFE（如1步）下也能生成高质量样本。</li></ul><p>之后有需要了再细看吧。。</p><h2 id=rl4ad>RL4AD<a hidden class=anchor aria-hidden=true href=#rl4ad>#</a></h2><h3 id=carl-learning-scalable-planning-policies-with-simple-rewards>CaRL: Learning Scalable Planning Policies with Simple Rewards<a hidden class=anchor aria-hidden=true href=#carl-learning-scalable-planning-policies-with-simple-rewards>#</a></h3><p>Bernhard Jaeger et al. University of Tübingen）
熟悉的作者，熟悉的配方</p><p><a href=https://arxiv.org/pdf/2504.17838>arxiv</a> <a href=https://github.com/autonomousvision/CaRL>github</a></p><p>有一说一，这个工作非常 straightforward。RL是非常 consume rollout 次数的，我觉得 CARLA 直接练还是很难加速，资源消耗太大了，必须尽量避免如此直接的方法，除非有什么魔法能不用练几下就能达到很好的效果，比如有一个很好的 backbone VLA 只需要少许微调，不用在 CARLA 上从零开始。但是他这个说是 Due to these optimizations, we were able to reproduce Roach with 10 million environment samples in 32 hours on a single A100 GPU. 如果这样的话，倒还好。</p><blockquote><p><strong>CaRL 提出了一种极简的强化学习奖励设计，仅用“路线完成度”+惩罚项，就能在大规模数据下训练出高效、鲁棒的自动驾驶规划策略，在 CARLA 和 nuPlan 上都取得了 SOTA 性能。</strong></p></blockquote><h4 id=极简奖励设计simple-reward>极简奖励设计（Simple Reward）<a hidden class=anchor aria-hidden=true href=#极简奖励设计simple-reward>#</a></h4><blockquote><p><strong>只用一个奖励项：路线完成度（Route Completion, RC）</strong></p></blockquote><h4 id=奖励公式>奖励公式：<a hidden class=anchor aria-hidden=true href=#奖励公式>#</a></h4><pre tabindex=0><code>reward = RC * ∏(soft penalty) - terminal penalty
</code></pre><ul><li><p><strong>软惩罚</strong>：如超速、偏离车道、舒适性等，乘性衰减；</p></li><li><p><strong>硬惩罚</strong>：如碰撞、闯红灯，直接终止 episode；</p></li><li><p><strong>无规则参考</strong>：不依赖任何规则系统，避免性能上限。</p></li></ul><h4 id=可扩展训练scalable-training>可扩展训练（Scalable Training）<a hidden class=anchor aria-hidden=true href=#可扩展训练scalable-training>#</a></h4><ul><li><strong>PPO 在大 batch size 下失效</strong>：复杂奖励在大 batch 下容易陷入局部最优；</li><li><strong>简单奖励可扩展</strong>：在大 batch 下性能反而提升；</li><li><strong>训练规模</strong>：<ul><li>CARLA：300M samples（30× 以往工作）</li><li>nuPlan：500M samples</li><li>使用 8-GPU 单机训练，DD-PPO 分布式训练框架</li></ul></li></ul><h4 id=工程优化>工程优化<a hidden class=anchor aria-hidden=true href=#工程优化>#</a></h4><ul><li><strong>CARLA 训练加速</strong>：<ul><li>不重启 town、预计算 A* 路径</li><li>异步数据收集（AC-PPO）</li><li>场景自动生成脚本</li></ul></li><li><strong>nuPlan 适配</strong>：<ul><li>增加 survival bonus 防止提前完成任务后“摆烂”</li></ul></li></ul><h3 id=action-space-reduction-strategies-for-reinforcement-learning-in-autonomous-driving>Action Space Reduction Strategies for Reinforcement Learning in Autonomous Driving<a hidden class=anchor aria-hidden=true href=#action-space-reduction-strategies-for-reinforcement-learning-in-autonomous-driving>#</a></h3><p><a href=https://arxiv.org/abs/2507.05251>arxiv</a> 暂未开源&mldr;</p><p>是一个在 CARLA 里 RL 的小改进，就是减小动作空间。具体在训练上也是直接 PPO，倒是创新性有限（？）。</p><blockquote><p><strong>论文提出两种新方法（动态掩码 + 相对动作）来“聪明地砍掉无用动作”，</strong><br><strong>在 CARLA 仿真中让 PPO 智能体训练提速 2 倍，成功率更高，驾驶更平滑。</strong></p></blockquote><h4 id=提出的两种新方法>提出的两种新方法<a hidden class=anchor aria-hidden=true href=#提出的两种新方法>#</a></h4><table><thead><tr><th>方法</th><th>核心思想</th><th>动作空间大小</th><th>特点</th></tr></thead><tbody><tr><td><strong>Dynamic Masking</strong></td><td><strong>每帧只保留当前方向盘 ±0.2 范围内的 5 个转向 + 2 个油门</strong>，其余动作被二进制掩码设为无效</td><td>仍为 42 维，但有效动作只剩 5×2=10 个</td><td>实时、上下文相关，避免无效探索</td></tr><tr><td><strong>Relative Reduction</strong></td><td><strong>动作改为“相对调整”</strong>：{-0.2, -0.1, 0, 0.1, 0.2}，加到当前方向盘上**</td><td>固定 5×2=10 维</td><td>动作空间维度不变，但物理意义更平滑，天然限制越界</td></tr></tbody></table><h4 id=实验验证carla-town07>实验验证（CARLA Town07）<a hidden class=anchor aria-hidden=true href=#实验验证carla-town07>#</a></h4><table><thead><tr><th>指标</th><th>结果</th></tr></thead><tbody><tr><td><strong>训练时间</strong></td><td>动态/相对方法比“全动作空间”<strong>快 2 倍</strong></td></tr><tr><td><strong>成功率</strong></td><td><strong>Rel-0.5</strong> 和 <strong>Dyn-0.5</strong> 在大多数场景 ≥ 70%，甚至 100%</td></tr><tr><td><strong>控制平滑性</strong></td><td>车道偏离显著降低（Rel-0.5 仅 0.10 m vs 全动作 0.31 m）</td></tr><tr><td><strong>复杂场景</strong></td><td>多转弯、十字路口也能稳定完成</td></tr></tbody></table><h4 id=关键结论>关键结论<a hidden class=anchor aria-hidden=true href=#关键结论>#</a></h4><ul><li><strong>动作空间不是越大越好</strong>——合理缩减反而提升性能。</li><li><strong>动态掩码</strong> 和 <strong>相对动作</strong> 在 <strong>速度、成功率、平滑性</strong> 之间取得最佳平衡。</li><li><strong>可移植性高</strong>：方法独立于网络结构，可插拔到任何 RL 框架（PPO、SAC、DDPG 等）。</li></ul><h3 id=reinforcement-learning-with-action-chunking>Reinforcement Learning with Action Chunking<a hidden class=anchor aria-hidden=true href=#reinforcement-learning-with-action-chunking>#</a></h3><p><a href=https://arxiv.org/abs/2507.07969>arxiv</a> 未有开源代码</p><p>Qiyang Li, Zhiyuan Zhou, Sergey Levine. UC Berkeley</p><p>我对 RL 还并不内行，之后再细看</p><p>这篇论文《Reinforcement Learning with Action Chunking》提出了一种<strong>简单但高效的强化学习方法（Q-chunking）</strong>，专门解决<strong>长周期、稀疏奖励任务</strong>在<strong>离线到在线（offline-to-online）RL</strong>场景下的<strong>探索困难和样本效率低</strong>的问题。</p><h4 id=-一句话总结>✅ 一句话总结：<a hidden class=anchor aria-hidden=true href=#-一句话总结>#</a></h4><blockquote><p><strong>Q-chunking 把“动作序列”当作一个整体来训练和探索，使得 RL 在稀疏奖励任务中能更快、更稳地从离线数据中学到东西，再在线微调。</strong></p></blockquote><h4 id=-核心思想动作分块action-chunking>🎯 核心思想：动作分块（Action Chunking）<a hidden class=anchor aria-hidden=true href=#-核心思想动作分块action-chunking>#</a></h4><table><thead><tr><th>传统 RL</th><th>Q-chunking</th></tr></thead><tbody><tr><td>每一步预测一个动作</td><td>每次预测一个<strong>动作序列（chunk）</strong>，比如未来 5 步</td></tr><tr><td>探索靠随机扰动</td><td>探索靠<strong>模仿离线数据中的连贯行为</strong>，更高效</td></tr><tr><td>1 步 TD 更新慢</td><td>使用<strong>无偏的 n 步 TD 更新</strong>，更快传播价值信号</td></tr></tbody></table><h4 id=-关键技术点>💡 关键技术点<a hidden class=anchor aria-hidden=true href=#-关键技术点>#</a></h4><table><thead><tr><th>模块</th><th>说明</th></tr></thead><tbody><tr><td><strong>动作空间扩展</strong></td><td>把动作从 <code>a_t</code> 变成 <code>a_t:t+h</code>，即一个长度为 h 的序列</td></tr><tr><td><strong>行为约束</strong></td><td>用 Flow Matching 学一个行为策略，限制策略不过度偏离离线数据</td></tr><tr><td><strong>无偏 n-step TD</strong></td><td>用完整的动作序列做 TD 更新，避免传统 n-step 的偏差问题</td></tr><tr><td><strong>两种实现</strong></td><td>QC（基于 best-of-N 采样）和 QC-FQL（基于 Flow Q-learning）</td></tr></tbody></table><h4 id=-实验结果>🧪 实验结果<a hidden class=anchor aria-hidden=true href=#-实验结果>#</a></h4><table><thead><tr><th>基准</th><th>表现</th></tr></thead><tbody><tr><td><strong>OGBench（5 个任务）</strong></td><td>Q-chunking 在最难的 cube-quadruple 上远超所有基线</td></tr><tr><td><strong>Robomimic（3 个任务）</strong></td><td>在 lift/can/square 上均优于 RLPD、FQL 等</td></tr><tr><td><strong>样本效率</strong></td><td>仅用 100 万步在线训练就能解决原本几乎学不到的任务</td></tr><tr><td><strong>探索质量</strong></td><td>动作更连贯，覆盖更多状态空间，避免“原地抖动”</td></tr></tbody></table><blockquote><p><strong>Q-chunking 通过“动作序列预测 + 行为约束 + n-step TD”，让 RL 在稀疏奖励任务中更快、更稳地从离线数据中学到策略，适用于机器人操作等长周期任务。</strong></p></blockquote><h3 id=breaking-imitation-bottlenecks-reinforced-diffusion-powers-diverse-trajectory-generation>Breaking Imitation Bottlenecks: Reinforced Diffusion Powers Diverse Trajectory Generation<a hidden class=anchor aria-hidden=true href=#breaking-imitation-bottlenecks-reinforced-diffusion-powers-diverse-trajectory-generation>#</a></h3><p>Ziying Song, Lin Liu, Hongyu Pan, Bencheng Liao, Mingzhe Guo, Lei Yang, Yongchang Zhang, Shaoqing Xu, Caiyan Jia, Yadan Luo</p><p><a href=https://www.arxiv.org/abs/2507.04049>arxiv</a> 暂无开源</p><blockquote><p>dp + rl，好文。多条轨迹候选我觉得也是一个可行的方式，像之前张兆翔那篇也是这么搞的，预制几个然后diffusion出来实际的。不过他搞了 diffusion policy + rl,领先一步,而且做得非常扎实.应当多看</p></blockquote><blockquote><p>这篇论文提出 <strong>DIVER</strong> —— 首个用 <strong>扩散模型 + 强化学习</strong> 的端到端自动驾驶框架，专门解决传统模仿学习中“<strong>模式崩溃、轨迹单一、过于保守</strong>”的顽疾，让车辆真正生成<strong>多样化且安全可行</strong>的未来轨迹。</p></blockquote><p>核心痛点<br>• 现有方法只用一条专家轨迹做模仿，导致：<br>– 所有预测轨迹都“挤”在专家轨迹附近 → 模式崩溃<br>– 不敢变道/超车，无法应对复杂场景</p><p>DIVER 的解法（三步走）</p><ol><li><p>Policy-Aware Diffusion Generator (PADG)<br>‑ 同时输入：地图、周边车辆、<strong>多条参考轨迹</strong>（变道、让行、超车…）<br>‑ 扩散模型一次性生成 M 条多样轨迹，而非单条均值轨迹</p></li><li><p>强化学习“纠偏”<br>‑ 把扩散过程视为<strong>随机策略</strong><br>‑ 用 GRPO 优化<strong>多样性奖励 + 安全性奖励</strong>：<br>• 多样性：轨迹间距离越大越好<br>• 安全：离障碍物越远越好</p></li><li><p>新指标 & 训练损失<br>‑ 提出 <strong>Diversity Metric</strong>（[0,1] 范围）专门衡量多模态轨迹离散度<br>‑ 用 <strong>匈牙利匹配损失</strong> 将每条预测轨迹对齐到不同参考意图，避免收敛到同一均值</p></li></ol><p>实验结果<br>• <strong>Bench2Drive 闭环</strong>：成功率 ↑29 %、超车能力 ↑3.8 %、紧急制动 ↑5.5 %<br>• <strong>NuScenes 开环</strong>：平均多样性指标 ↑61 %，碰撞率 ↓12.5 %<br>• 在<strong>转弯、对抗、雨雪雾</strong>等子集上均优于 VAD、SparseDrive、DiffusionDrive 等 SOTA</p><p>DIVER 把“扩散去噪过程”当成一个<strong>可学习的随机策略</strong>（policy），然后用 <strong>Group Relative Policy Optimization（GRPO）</strong> 做 RL 微调，核心流程如下：</p><h4 id=rl-做-dp-详细方法>rl 做 dp 详细方法<a hidden class=anchor aria-hidden=true href=#rl-做-dp-详细方法>#</a></h4><p><strong>1. 把扩散模型当策略</strong></p><ul><li>扩散模型每一步的 denoising 网络 <code>εθ(τt, t)</code> 就是<strong>策略 πθ</strong></li><li>输入：当前噪声轨迹 <code>τt</code> + 场景条件</li><li>输出：下一步去噪方向（相当于动作）</li></ul><p><strong>2. 设计两条 reward 信号</strong></p><table><thead><tr><th>奖励</th><th>公式（直觉）</th><th>作用</th></tr></thead><tbody><tr><td><strong>多样性奖励 rdiv</strong></td><td><code>1/M(M-1) Σ‖τi − τj‖₂</code></td><td>最大化轨迹间距离，防止模式崩溃</td></tr><tr><td><strong>安全奖励 rsafe</strong></td><td><code>−1/T Σ 𝟙[Dsafety(xt) &lt; dthresh]</code></td><td>离障碍物越近惩罚越大，保证物理可行</td></tr></tbody></table><p><strong>总奖励</strong>：<code>r(τ) = rdiv + λ·rsafe</code></p><p><strong>3. 用 GRPO 更新策略</strong></p><ul><li>对每个场景采样 <strong>G 条轨迹</strong>（group）</li><li>计算组内 <strong>相对优势</strong>（relative advantage）：<br><code>Ai = ri − mean(rgroup)</code></li><li>GRPO 目标：<br><code>JGRPO = E[min(wi Ai, clip(wi,1±ε) Ai)] − β·DKL(πθ‖πref)</code><br><code>wi = πθ/πold</code>（重要性采样比）</li></ul><p><strong>4. 训练损失组合</strong>
<code>Ltotal = λmatch·Lmatch + λRL·LRL</code></p><ul><li><code>Lmatch</code>：匈牙利匹配损失，保证每条预测轨迹对齐不同意图</li><li><code>LRL</code>：GRPO 损失，直接用不可微的 <code>rdiv + rsafe</code> 优化扩散策略</li></ul><h4 id=结果>结果<a hidden class=anchor aria-hidden=true href=#结果>#</a></h4><ul><li>无需手工标签，仅靠奖励即可让扩散模型**“敢变道”<strong>、</strong>“懂避障”**</li><li>在闭环 Bench2Drive 上：成功率 ↑29 %，多样性 ↑66 %，碰撞率 ↓12 %</li></ul><blockquote><p><strong>DIVER 把扩散去噪视为策略，用 GRPO + diversity/safety reward 直接微调，突破了模仿学习的“单专家”枷锁。</strong></p></blockquote><h3 id=dyna-reinforcement-learning-in-real-world>DYNA: Reinforcement Learning in Real World<a hidden class=anchor aria-hidden=true href=#dyna-reinforcement-learning-in-real-world>#</a></h3><p><a href=https://www.dyna.co/dyna-1/research>Research - DYNA Robotics | Research</a> 这个不是论文,,,</p><h2 id=vla>VLA<a hidden class=anchor aria-hidden=true href=#vla>#</a></h2><h3 id=fedvla-federated-vision-language-action-learning-with-dual-gating-mixture-of-experts-for-robotic-manipulation>FedVLA: Federated Vision-Language-Action Learning with Dual Gating Mixture-of-Experts for Robotic Manipulation<a hidden class=anchor aria-hidden=true href=#fedvla-federated-vision-language-action-learning-with-dual-gating-mixture-of-experts-for-robotic-manipulation>#</a></h3><p>Cui Miao1 TaoChang1 MeihanWu1 HongbinXu2 Chun Li3 MingLi4* Xiaodong Wang1 1 National University of Defense Technology 2Bytedance Seed 3Shenzhen MSU-BIT University 4Guangdong Laboratory of Artificial Intelligence and Digital Economy (SZ)</p><p><a href=https://arxiv.org/abs/2508.02190>arxiv</a></p><blockquote><p>分布式训练 VLA，现在我这边可能不太需要吧，先放在这</p></blockquote><p>这篇文章提出了一种名为 <strong>FedVLA</strong> 的联邦学习框架，用于在机器人操作任务中训练 <strong>视觉-语言-动作（VLA）模型</strong>，同时保护用户隐私。文章的核心贡献是解决了<strong>如何在分布式环境中高效训练多模态机器人模型</strong>，同时<strong>避免集中式训练带来的隐私风险</strong>。</p><blockquote><p>FedVLA 是第一个用于机器人操作任务的联邦视觉-语言-动作学习框架，它通过“任务感知特征提取 + 双向专家选择 + 专家驱动的聚合策略”，在保护隐私的同时实现了接近集中式训练的性能。</p></blockquote><h4 id=fedvla-的三大创新模块>FedVLA 的三大创新模块<a hidden class=anchor aria-hidden=true href=#fedvla-的三大创新模块>#</a></h4><table><thead><tr><th>模块名称</th><th>作用</th><th>关键技术</th></tr></thead><tbody><tr><td><strong>IOSP</strong>（Instruction-Oriented Scene-Parsing）</td><td>把图像分解为“任务相关”的对象表示</td><td>用CLIP模型将图像中的目标物体、周围物体、背景物体与语言指令对齐</td></tr><tr><td><strong>DGMoE</strong>（Dual Gating Mixture-of-Experts）</td><td>让模型根据任务复杂度动态选择专家，提高计算效率</td><td>引入“<strong>自感知专家</strong>”，专家可以主动决定是否接收token，实现双向选择</td></tr><tr><td><strong>EDA</strong>（Expert-Driven Aggregation）</td><td>在联邦聚合时，优先合并“专家选择相似”的客户端模型</td><td>利用专家激活向量计算客户端之间的相似度，动态分配聚合权重</td></tr></tbody></table><h4 id=实验验证>实验验证<a hidden class=anchor aria-hidden=true href=#实验验证>#</a></h4><p><strong>✅ 模拟环境（Meta-World）</strong></p><ul><li>任务：关门、关抽屉、扫地、开窗</li><li>FedVLA 成功率：<strong>63.3%</strong>（vs 集中式 65.0%，FedAvg 51.7%）</li></ul><p><strong>✅ 真实世界（UR3机械臂）</strong></p><ul><li>任务：清理桌面、扔垃圾、开抽屉、分药</li><li>FedVLA 成功率：<strong>63.3%</strong>（vs 集中式 63.4%，FedAvg 53.3%）</li></ul><h3 id=vote-vision-language-action-optimization-with-trajectory-ensemble-voting>VOTE: Vision-Language-Action Optimization with Trajectory Ensemble Voting<a hidden class=anchor aria-hidden=true href=#vote-vision-language-action-optimization-with-trajectory-ensemble-voting>#</a></h3><p><a href=https://arxiv.org/abs/2507.05116>arxiv</a> [github](<a href=https://github.com/LukeLIN-web/VOTE>https://github.com/LukeLIN-web/VOTE</a> 仅几天前开源，16stars)</p><blockquote><p><strong>VOTE 提出“单令牌动作 + 投票集成”的轻量级 VLA 框架，把生成动作所需的 token 数量从上百个压缩到 1 个，同时在推理阶段用历史预测投票纠错，实现 39× 推理加速、98% LIBERO 成功率，并能在边缘设备 46 Hz 实时运行。</strong></p></blockquote><table><thead><tr><th>传统 VLA 模型</th><th>问题</th></tr></thead><tbody><tr><td>多 token / 扩散动作头</td><td><strong>推理慢</strong>：OpenVLA/CogACT 每步 200 ms 以上</td></tr><tr><td>只执行当前预测</td><td><strong>动作浪费</strong>：上一帧预测被丢弃，轨迹抖动</td></tr><tr><td>3D/扩散增强</td><td><strong>训练贵</strong>：显存大、梯度步数多</td></tr></tbody></table><h4 id=1-训练阶段单令牌动作>1️⃣ 训练阶段：单令牌动作<a hidden class=anchor aria-hidden=true href=#1-训练阶段单令牌动作>#</a></h4><ul><li>在 LLM tokenizer 内新增 <code>&lt;ACT></code> 特殊 token</li><li><strong>一次前向只生成 1 个 token</strong> → 隐藏态直接输入轻量 MLP 动作头</li><li><strong>token 数从 N×D ↓ 1</strong>（N=chunk, D=action dim）</li><li>LoRA+瓶颈 MLP，训练步数≈OpenVLA-OFT 的 <strong>15–54 %</strong></li></ul><h4 id=2-推理阶段trajectory-ensemble-voting>2️⃣ 推理阶段：Trajectory Ensemble Voting<a hidden class=anchor aria-hidden=true href=#2-推理阶段trajectory-ensemble-voting>#</a></h4><ul><li>维护一个 <strong>K+1 步动作委员会</strong>（历史+当前）</li><li>用余弦相似度投票，<strong>选多数派平均值</strong>作为最终动作</li><li><strong>τ=0.5</strong> 经验阈值即可，无需调参</li><li>融合后轨迹更平滑，平均提升 <strong>5–10 % SR</strong></li></ul><table><thead><tr><th>场景</th><th>数据量</th><th>成功率</th><th>延迟/吞吐</th><th>边缘设备</th></tr></thead><tbody><tr><td><strong>LIBERO-4 套件</strong></td><td>50–130K 步</td><td><strong>98 %</strong></td><td>78 ms / 102 Hz</td><td>46 Hz @Jetson Orin</td></tr><tr><td><strong>SimplerEnv-WidowX</strong></td><td>60K 步</td><td><strong>58 %</strong></td><td>78 ms</td><td>实时</td></tr><tr><td><strong>Google Robot</strong></td><td>150K 步</td><td><strong>74 %</strong></td><td>78 ms</td><td>实时</td></tr></tbody></table><ul><li><strong>比 OpenVLA 快 39×</strong>，显存占用 <strong>-50 %</strong></li><li><strong>比 CogACT 高 7 % SR</strong>，边缘设备 CogACT OOM</li></ul><blockquote><p><strong>VOTE 用“1 个 token 生成整个动作块 + 历史投票纠错”，让 VLA 模型在边缘设备上也能以 46 Hz 的实时速度完成高成功率机器人操作。</strong></p></blockquote><h4 id=训练用数据>训练用数据<a hidden class=anchor aria-hidden=true href=#训练用数据>#</a></h4><p><strong>1️⃣ 数据模态</strong></p><table><thead><tr><th>模态</th><th>说明</th></tr></thead><tbody><tr><td><strong>RGB 图像</strong></td><td>1 张 224×224 第三人称相机图像（或更多视角可扩展）</td></tr><tr><td><strong>语言指令</strong></td><td>自然语言任务描述（如 “put the cup on the table”）</td></tr><tr><td><strong>动作标签</strong></td><td>连续 7-DoF 末端位姿 + 1 维夹爪开闭（共 8 维）</td></tr><tr><td><strong>动作块（chunk）</strong></td><td>连续 N 步动作序列（N=8 或 16，按实验设定）</td></tr></tbody></table><blockquote><p><strong>无需深度图、点云、3D 姿态等额外模态</strong>，保持极简输入。</p></blockquote><p><strong>2️⃣ 数据量（按任务/场景）</strong></p><table><thead><tr><th>场景</th><th>单任务数据量</th><th>总数据量</th><th>备注</th></tr></thead><tbody><tr><td><strong>LIBERO 基准</strong></td><td>50–130K 步</td><td>4 个任务 × 50–130K ≈ <strong>200–520K 步</strong></td><td>每个任务 500 条演示 × 100 步</td></tr><tr><td><strong>SimplerEnv</strong></td><td>60K 步</td><td>1 个任务 ≈ <strong>60K 步</strong></td><td>BridgeDataV2 子集</td></tr><tr><td><strong>真实机器人</strong></td><td>类似量级</td><td>视任务而定</td><td>论文未明确，但经验值 <strong>50–200 条演示/任务</strong></td></tr></tbody></table><blockquote><p><strong>数据量远小于 OpenVLA-OFT</strong>（后者需 150K 步 × 64 batch）。</p></blockquote><p><strong>计算资源</strong></p><table><thead><tr><th>阶段</th><th>硬件需求</th><th>训练时间</th><th>显存占用</th><th>备注</th></tr></thead><tbody><tr><td><strong>微调 VLA（LoRA）</strong></td><td>2×H100 (94GB)</td><td>8–130K 步（1–3 天）</td><td>14–19 GB</td><td>全局 batch=40，LoRA rank=32</td></tr><tr><td><strong>边缘推理</strong></td><td>NVIDIA Jetson AGX Orin (32 GB)</td><td>实时 46 Hz</td><td><strong>346 ms 延迟</strong></td><td>无需再训练</td></tr><tr><td><strong>对比基线</strong></td><td>8×A100 (80GB)</td><td>150K 步 × 64 batch</td><td>19 GB</td><td>OpenVLA-OFT 资源</td></tr></tbody></table><blockquote><p><strong>VOTE 仅需 RGB + 语言 + 动作轨迹，单任务几十到几百条演示，2×H100 上 1–3 天即可微调完成，边缘设备实时运行。</strong></p></blockquote><h3 id=video-generators-are-robot-policies>Video Generators are Robot Policies<a hidden class=anchor aria-hidden=true href=#video-generators-are-robot-policies>#</a></h3><p>Junbang Liang, Pavel Tokmakov, Ruoshi Liu, Sruthi Sudhakar, Paarth Shah, Rares Ambrus, Carl Vondrick</p><p><a href=https://arxiv.org/abs/2508.00795>arxiv</a> 未开源</p><blockquote><p>不看好非要生成视频的模型，跑不起来&mldr; 8*A100 练两周真绷不住了</p></blockquote><blockquote><p><strong>本文提出“Video Policy”：用大规模视频生成模型当“世界模拟器”，再配一个轻量级动作解码器，就能把生成视频直接变成机器人策略，实现</strong>少量动作数据、强鲁棒性的泛化控制**。</p></blockquote><h4 id=-核心思路把视频生成当策略>📌 核心思路：把“视频生成”当策略<a hidden class=anchor aria-hidden=true href=#-核心思路把视频生成当策略>#</a></h4><ol><li><strong>先视频</strong>：用 <strong>Stable Video Diffusion (SVD)</strong> 级联模型，根据 <strong>初始图像 + 语言任务</strong> 生成未来机器人执行视频帧。</li><li><strong>后动作</strong>：用 <strong>轻量级 1D-CNN U-Net</strong> 从视频隐藏层特征解码 <strong>7-DoF 末端位姿 + 夹爪开闭</strong> 的连续动作序列。</li></ol><blockquote><p>因为 SVD 已在互联网海量视频里学到通用动力学，<strong>动作解码器只需 50~200 条演示即可泛化</strong>。</p></blockquote><h4 id=-训练与数据>📌 训练与数据<a hidden class=anchor aria-hidden=true href=#-训练与数据>#</a></h4><table><thead><tr><th>阶段</th><th>数据</th><th>计算资源</th><th>说明</th></tr></thead><tbody><tr><td><strong>视频预训练</strong></td><td>互联网通用视频</td><td>8×A100，两周</td><td>微调 SVD</td></tr><tr><td><strong>动作微调</strong></td><td>每任务 <strong>50 条人演示</strong>（或 300M MimicGen）</td><td>同上</td><td>冻结视频权重，只训动作头</td></tr><tr><td><strong>真实世界</strong></td><td>200 条/任务（5 任务）</td><td>RTX 4070 Laptop</td><td>实时 30 步扩散推理</td></tr></tbody></table><h4 id=-主要结果>📌 主要结果<a hidden class=anchor aria-hidden=true href=#-主要结果>#</a></h4><table><thead><tr><th>Benchmark</th><th>数据量</th><th>平均成功率</th><th>对比</th></tr></thead><tbody><tr><td><strong>RoboCasa-24 任务</strong></td><td>50 demo</td><td><strong>66%</strong></td><td>超 DP-ResNet、UVA、GR00T 等</td></tr><tr><td><strong>LIBERO-10</strong></td><td>50 demo</td><td><strong>94%</strong></td><td>显著优于 UVA</td></tr><tr><td><strong>真实 5 任务</strong></td><td>200 demo</td><td>0.3-1.0</td><td>对未见物体/背景/位置均泛化</td></tr></tbody></table><h4 id=-关键发现>📌 关键发现<a hidden class=anchor aria-hidden=true href=#-关键发现>#</a></h4><ol><li><strong>2-阶段训练 > 联合训练</strong>：先训视频再训动作，效果更好（63% vs 57%）。</li><li><strong>越长视频预测越泛化</strong>：32 步视频预测在分布偏移任务上收益最大。</li><li><strong>无动作视频也能泛化</strong>：仅动作头训 12/24 任务，靠视频先验仍超过基线。</li><li><strong>实时瓶颈</strong>：25 帧 256×256 在 A100 上需 ~9 秒，但加速技术可解。</li></ol><h3 id=pre-training-auto-regressive-robotic-models-with-4d-representations>Pre-training Auto-regressive Robotic Models with 4D Representations<a hidden class=anchor aria-hidden=true href=#pre-training-auto-regressive-robotic-models-with-4d-representations>#</a></h3><p><strong>ARM4R</strong> ——用“人视频里学 4D 轨迹（3D 点+时间）”来预训练机器人策略，结果只用 1/10 的机器人数据就超过了 OpenVLA、π0-FAST 等 SOTA 方法说是。而且他这个用的资源也不多：&ldquo;Finally, we use 4 NVIDIA A6000 GPUs for training and a single NVIDIA A6000 GPU for evaluation.&rdquo;</p><p>先插一嘴，它的网站做得不错，分两栏，左边图片右边文字。虽然也是套模板，但是做了点小改动：<a href=https://arm4r.github.io/>website</a> 但是看多了也就那样，对手机用户不太友好。</p><p>ARM4R 的完整模型 =「四路编码器 + 一个自回归 Transformer + 解码器」。下面给出可直接落地的<strong>架构细节</strong>与<strong>训练脚本骨架</strong>（PyTorch 伪码），按三阶段顺序展开。</p><p>──────────────────</p><h4 id=模型架构>模型架构<a hidden class=anchor aria-hidden=true href=#模型架构>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>输入 (t 时刻)
</span></span><span class=line><span class=cl>├─ 语言指令 l               → 冻结 CLIP-T 文本编码器 → z_l
</span></span><span class=line><span class=cl>├─ 图像 i_t                 → 冻结 ViT-B/16           → z_i
</span></span><span class=line><span class=cl>├─ 3D 点/机器人状态 p_t     → 2 层 MLP                → z_p
</span></span><span class=line><span class=cl>└─ 历史信息                → 拼接后喂给 Causal Transformer
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Transformer：随机初始化 ViT-Base（12 层、768 维、8 头），因果注意力，窗口 C=16（或32）。  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>输出
</span></span><span class=line><span class=cl>├─ 未来 3D 点 p_{t+1}（Stage1/2）或未来机器人状态 s_{t+1}（Stage3）
</span></span><span class=line><span class=cl>└─ 解码：2 层 MLP 直接回归，L1 loss
</span></span></code></pre></div><h4 id=数据与预处理>数据与预处理<a hidden class=anchor aria-hidden=true href=#数据与预处理>#</a></h4><table><thead><tr><th>阶段</th><th>数据</th><th>伪标签生成</th><th>采样率</th></tr></thead><tbody><tr><td>Stage1</td><td>Epic-Kitchens100 76k 视频</td><td>SpatialTracker 产生 3D 点轨迹（g×g 网格）</td><td>10 fps</td></tr><tr><td>Stage2</td><td>1–2 k 机器人演示视频</td><td>同上</td><td>10 fps</td></tr><tr><td>Stage3</td><td>190 × 任务变体 成功轨迹（末端位姿+夹爪）</td><td>无伪标签，直接用机器人真值</td><td>10 fps</td></tr></tbody></table><p>把整个流程封装成 <strong>「人视频→3D 轨迹预训练」→「机器人视频→3D 轨迹微调」→「机器人动作→控制微调」</strong>，只需替换最后一步的 MLP 头即可。</p><h4 id=训练过程>训练过程<a hidden class=anchor aria-hidden=true href=#训练过程>#</a></h4><p>──────────────────<br>阶段 1：人视频 4D 轨迹预训练<br>• 数据<br>– 76 k 条 Epic-Kitchens100 egocentric 人视频（75 041 条有效）。<br>– 无人工动作标签，只用 <strong>伪 3D 点轨迹</strong>：<br>- 在首帧布 g×g 网格 → SpatialTracker 产生每帧 3D 坐标（相机坐标系）。<br>• 训练任务<br>– 「给定语言指令 + 当前图像 + 当前 3D 点 p_t → 预测 t+1 的 3D 点 p_t+1」。<br>– 采用 <strong>自回归 next-token 范式</strong>，损失为 L1(p̂_t+1, p_t+1)。</p><p>──────────────────<br>阶段 2：机器人场景 4D 轨迹微调（一次即可，跨任务共享）<br>• 数据<br>– 每条任务仅 <strong>5–10 % 阶段 1 数据量</strong>，即 1–2 k 段机器人演示视频。<br>– 仍用 SpatialTracker 产生 3D 点轨迹，但相机固定，场景为机器人。<br>• 训练任务<br>– 与阶段 1 相同：预测 3D 点 → 解决人→机器人相机/场景分布差异。</p><p>──────────────────<br>阶段 3：机器人控制微调（任务专用）<br>• 数据<br>– <strong>190 段成功演示/任务</strong>（比基线少 10×）。<br>– 观测：语言指令 + 图像 + <strong>机器人当前状态 s_t（末端位姿+夹爪）</strong>。<br>– 标签：下一时刻状态 s_t+1。<br>• 训练任务<br>– 把阶段 1/2 的 <strong>3D 点输入/输出通道</strong> 换成 <strong>机器人状态通道</strong>；<br>– 仍用自回归 Transformer，损失 L1(ŝ_t+1, s_t+1)。<br>– 预测 16 步，执行第 1 步（滚动时域）。</p><p>──────────────────<br>把「人视频里学 3D 点轨迹」→「机器人视频里继续学 3D 点轨迹」→「把预测目标换成机器人状态」，总共使用的数据有：</p><ol><li>大量无标人视频（+ SpatialTracker 伪轨迹）；</li><li>少量机器人演示视频（同伪轨迹）；</li><li>目标任务少量成功轨迹（用于阶段 3）。</li></ol><h3 id=mp1-meanflow-tames-policy-learning-in-1-step-for-robotic-manipulation>MP1: MeanFlow Tames Policy Learning in 1-step for Robotic Manipulation<a hidden class=anchor aria-hidden=true href=#mp1-meanflow-tames-policy-learning-in-1-step-for-robotic-manipulation>#</a></h3><p><a href=https://arxiv.org/abs/2507.10543>arxiv</a></p><p>北大的工作，刚开源三周左右，10 stars</p><blockquote><p><strong>MP1 是第一个将 MeanFlow（平均速度场）引入机器人操作任务的方法，</strong><br><strong>仅用 1 步推理（1-NFE）即可输出高质量动作轨迹，</strong><br><strong>在多个仿真与真实任务中显著优于扩散模型（如 DP3）和流模型（如 FlowPolicy）。</strong></p></blockquote><table><thead><tr><th>方法类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>Diffusion Policy（如 DP3）</strong></td><td>多模态、鲁棒性强</td><td>推理慢（需 10+ NFE）</td></tr><tr><td><strong>Flow Policy（如 FlowPolicy）</strong></td><td>1-NFE 推理快</td><td>需一致性约束，误差大</td></tr><tr><td><strong>MeanFlow（图像生成）</strong></td><td>1-NFE、无需一致性</td><td>尚未用于机器人任务</td></tr></tbody></table><blockquote><p>❗ <strong>MP1 首次将 MeanFlow 引入机器人学习，解决“快 vs 准”的权衡问题。</strong></p></blockquote><table><thead><tr><th>模块</th><th>设计</th><th>作用</th></tr></thead><tbody><tr><td><strong>MeanFlow Identity</strong></td><td>直接建模平均速度场，绕过 ODE 积分</td><td>实现真正 1-NFE 推理</td></tr><tr><td><strong>Dispersive Loss</strong></td><td>无正样本的对比正则项，拉开不同状态嵌入</td><td>提升少样本泛化能力</td></tr><tr><td><strong>CFG（Classifier-Free Guidance）</strong></td><td>增强可控性</td><td>不影响 1-NFE 推理速度</td></tr><tr><td><strong>3D Point Cloud Input</strong></td><td>使用 512/1024 点云作为视觉输入</td><td>提升空间理解能力</td></tr></tbody></table><h4 id=原理>原理<a hidden class=anchor aria-hidden=true href=#原理>#</a></h4><p><strong>输入处理</strong></p><ul><li><strong>视觉输入</strong>：3D 点云 → 3D Projection → 特征向量 <code>fv</code></li><li><strong>状态输入</strong>：机器人关节状态 → 全连接层 → 特征向量 <code>fs</code></li><li><strong>条件向量</strong>：<code>c = concat(fv, fs)</code></li></ul><p><strong>MeanFlow 建模</strong></p><p>$$u(z_t, r, t) = \frac{1}{t-r} \int_r^t v(z_\tau, \tau), d\tau$$</p><ul><li>通过 <strong>MeanFlow Identity</strong> 直接回归平均速度场，无需 ODE 求解；</li><li>训练目标为：</li></ul><p>$$L_{\mathrm{cfg}} = \left\lVert u_\theta - \mathrm{sg}(u_{\mathrm{target}}) \right\rVert^2$$</p><p><strong>Dispersive Loss（正则项）</strong></p><p>$$L_{\mathrm{disp}} = \log \mathbb{E}\left[\exp\left(-\frac{\lVert z_i - z_j \rVert^2}{\tau}\right)\right]$$</p><ul><li>无正样本的对比损失；</li><li>训练时增强表征区分度，推理时不增加成本。</li></ul><p><strong>最终损失</strong></p><p>$$L_{\mathrm{total}} = L_{\mathrm{cfg}} + \lambda \cdot L_{\mathrm{disp}}$$</p><h4 id=实验结果-1>实验结果<a hidden class=anchor aria-hidden=true href=#实验结果-1>#</a></h4><p><strong>仿真任务（Adroit + Meta-World，共 37 个任务）</strong></p><table><thead><tr><th>方法</th><th>NFE</th><th>平均成功率</th><th>平均推理时间</th></tr></thead><tbody><tr><td><strong>DP3</strong></td><td>10</td><td>68.7%</td><td>132.2 ms</td></tr><tr><td><strong>FlowPolicy</strong></td><td>1</td><td>71.6%</td><td>12.6 ms</td></tr><tr><td><strong>MP1 (ours)</strong></td><td>1</td><td><strong>78.9%</strong></td><td><strong>6.8 ms</strong></td></tr></tbody></table><blockquote><p>✅ <strong>MP1 比 DP3 快 19×，比 FlowPolicy 快 2×，且成功率提升 7.3%。</strong></p></blockquote><p><strong>真实世界任务（ARX R5 双臂机器人）</strong></p><table><thead><tr><th>任务</th><th>MP1 成功率</th><th>完成时间</th></tr></thead><tbody><tr><td>Hammer</td><td>90%</td><td>18.6s</td></tr><tr><td>Drawer Close</td><td>100%</td><td>8.8s</td></tr><tr><td>Heat Water</td><td>90%</td><td>23.4s</td></tr><tr><td>Stack Block</td><td>80%</td><td>27.2s</td></tr><tr><td>Spoon</td><td>90%</td><td>22.6s</td></tr></tbody></table><blockquote><p>✅ <strong>MP1 在所有任务中成功率最高，完成时间最短。</strong></p></blockquote><h4 id=数据需求>数据需求<a hidden class=anchor aria-hidden=true href=#数据需求>#</a></h4><table><thead><tr><th>数据项</th><th>格式</th><th>说明</th></tr></thead><tbody><tr><td><strong>专家轨迹</strong></td><td>每帧一条记录，包含：• 点云 <code>P ∈ ℝ^(N×3)</code>• 机器人状态 <code>S ∈ ℝ^s</code>（关节角/末端位姿）• 动作序列 <code>A ∈ ℝ^(K×a)</code></td><td><code>N=512/1024</code> 点，<code>K=4</code> 步预测，<code>a</code> 为动作维度</td></tr><tr><td><strong>训练集规模</strong></td><td>10 条演示即可收敛，20 条以上收益递减</td><td>与 DP3 / FlowPolicy 设置一致</td></tr><tr><td><strong>数据来源</strong></td><td>仿真（Adroit、Meta-World）或真实机器人（ARX R5）</td><td>仿真用 Isaac Gym / MuJoCo，真实用 ROS 采集</td></tr></tbody></table><h4 id=资源需求>资源需求<a hidden class=anchor aria-hidden=true href=#资源需求>#</a></h4><p>All training and testing are performed on an NVIDIA RTX4090 GPU,with a batch size of 128, optimization uses the AdamW optimizer with a learningrate of 0.0001 (Adroit and Meta-World apply the same learning rate), an observation window of 2steps, a history length of 4 states, and a prediction horizon of 4 steps.</p><h3 id=dreamvla-a-vision-language-action-model-dreamed-with-comprehensive-world-knowledge>DreamVLA: A Vision-Language-Action Model Dreamed with Comprehensive World Knowledge<a hidden class=anchor aria-hidden=true href=#dreamvla-a-vision-language-action-model-dreamed-with-comprehensive-world-knowledge>#</a></h3><p><a href=https://zhangwenyao1.github.io/DreamVLA/>website 标题跳动动画挺萌的</a> <a href=https://github.com/Zhangwenyao1/DreamVLA>github刚刚开源一个月已经139stars</a> <a href=https://arxiv.org/abs/2507.04447>arxiv</a></p><blockquote><p>典中典之先思考，用了 &lt;dream>思考过程&lt;action> 不过如果迁移到自动驾驶，感觉不太适用。练这个需要的数据模态太多，耗费资源大，再加上我觉得它更擅长于处理静态的场景&mldr;</p></blockquote><p>这篇论文《DreamVLA: A Vision-Language-Action Model Dreamed with Comprehensive World Knowledge》提出了一种<strong>新型的机器人操作策略框架</strong>，旨在通过<strong>预测未来世界知识</strong>（如动态区域、深度图、语义信息）来增强机器人的<strong>感知-预测-行动闭环能力</strong>，从而提升其在复杂任务中的泛化性和推理能力。</p><h4 id=模型组件>模型组件<a hidden class=anchor aria-hidden=true href=#模型组件>#</a></h4><table><thead><tr><th>模块</th><th>作用</th></tr></thead><tbody><tr><td><strong>World Knowledge Forecasting</strong></td><td>预测未来关键信息：动态区域（哪里会动）、深度（3D结构）、语义（物体类别）</td></tr><tr><td><strong>Block-wise Attention</strong></td><td>防止不同信息（动态、深度、语义）互相干扰，保持表示干净</td></tr><tr><td><strong>Diffusion-based Action Head</strong></td><td>用扩散模型从“世界知识”中解码出连续动作序列</td></tr><tr><td><strong>端到端训练</strong></td><td>统一训练视觉、语言、预测和动作，无需额外生成模型</td></tr></tbody></table><h4 id=模型改进>模型改进<a hidden class=anchor aria-hidden=true href=#模型改进>#</a></h4><table><thead><tr><th>传统方法</th><th>DreamVLA 的改进</th></tr></thead><tbody><tr><td>直接从图像+语言 → 动作，缺乏未来推理</td><td>先预测“未来世界状态”，再决定动作</td></tr><tr><td>预测整帧图像，冗余信息多</td><td>只预测关键区域（动态区域、深度、语义）</td></tr><tr><td>多模态信息混杂，互相干扰</td><td>用结构化注意力隔离不同信息</td></tr><tr><td>动作预测不稳定</td><td>用扩散模型生成平滑、物理合理的动作序列</td></tr></tbody></table><h4 id=实验结果-2>实验结果<a hidden class=anchor aria-hidden=true href=#实验结果-2>#</a></h4><table><thead><tr><th>场景</th><th>结果</th></tr></thead><tbody><tr><td><strong>仿真 CALVIN 基准</strong></td><td>平均任务长度 <strong>4.44</strong>（SOTA），优于 OpenVLA、GR-1 等方法</td></tr><tr><td><strong>真实机器人（Franka 臂）</strong></td><td>成功率 <strong>76.7%</strong>，显著高于 Diffusion Policy、OpenVLA 等基线</td></tr></tbody></table><h4 id=所需数据>所需数据<a hidden class=anchor aria-hidden=true href=#所需数据>#</a></h4><p><strong>📦 数据类型（多模态）</strong></p><table><thead><tr><th>模态</th><th>内容</th><th>格式</th></tr></thead><tbody><tr><td><strong>视觉</strong></td><td>RGB 图像（静态摄像头 + 手腕摄像头）</td><td>JPEG/PNG</td></tr><tr><td><strong>深度</strong></td><td>单目深度图（可选）</td><td>PNG 或 NumPy 数组</td></tr><tr><td><strong>语言</strong></td><td>自然语言任务指令</td><td>JSON 或纯文本</td></tr><tr><td><strong>动作</strong></td><td>连续 7 维动作（6D 位移 + 夹爪状态）</td><td>NumPy 数组</td></tr><tr><td><strong>状态</strong></td><td>机器人末端位姿 + 夹爪状态</td><td>NumPy 数组</td></tr><tr><td><strong>辅助标签</strong></td><td>动态区域掩码、SAM 分割、DINOv2 特征</td><td>NumPy 数组</td></tr></tbody></table><p><strong>数据来源与量级</strong></p><table><thead><tr><th>阶段</th><th>数据集</th><th>数据量</th><th>说明</th></tr></thead><tbody><tr><td><strong>预训练</strong></td><td><strong>DROID</strong></td><td><strong>7.6 万条机器人轨迹</strong></td><td>多样化真实场景，Franka 机器人操作</td></tr><tr><td><strong>预训练</strong></td><td><strong>CALVIN（无语言子集）</strong></td><td>约 240 万步交互</td><td>仿真环境，长周期任务</td></tr><tr><td><strong>微调</strong></td><td><strong>任务特定演示</strong></td><td><strong>每任务约 100 条轨迹</strong></td><td>真实机器人任务，如拾取、放置、抽屉开关</td></tr></tbody></table><h4 id=训练流程>训练流程<a hidden class=anchor aria-hidden=true href=#训练流程>#</a></h4><p><strong>阶段 1：预训练</strong></p><ul><li><strong>目标</strong>：让模型学会从多模态输入中预测“未来世界知识”（动态区域、深度、语义）。</li><li><strong>数据</strong>：DROID + CALVIN（无语言）。</li><li><strong>监督信号</strong>：<ul><li>动态区域：用 CoTracker 提取光流掩码</li><li>深度：Depth-Anything 伪标签</li><li>语义：DINOv2 + SAM 特征</li></ul></li><li><strong>训练设置</strong>：<ul><li>优化器：AdamW，学习率 1e-3，余弦调度，5% 预热</li><li>批量大小：8（每 GPU）× 8 GPU = 64</li><li>训练轮数：20 epochs</li><li>损失权重：<ul><li>动态区域：λ_dyn = 0.1</li><li>深度：λ_depth = 0.001</li><li>语义：λ_sem = 0.1</li><li>动作：λ_DiT = 1</li></ul></li></ul></li></ul><p><strong>阶段 2：微调</strong></p><ul><li><strong>目标</strong>：适应具体任务（如拾取、放置、抽屉操作）。</li><li><strong>数据</strong>：每个任务约 100 条真实机器人演示。</li><li><strong>训练方式</strong>：<ul><li>继续使用预训练权重</li><li>只训练解码器和动作头，冻结部分主干（可选）</li><li>选择验证成功率最高的 checkpoint 作为最终模型</li></ul></li></ul><blockquote><p><strong>训练 DreamVLA 需用 DROID（7.6万条）+ CALVIN 预训练，再用每任务约 100 条真实演示微调，数据需包含 RGB、语言、动作、动态掩码、深度和语义特征，训练采用两阶段策略，耗时约 20 epochs，8×A800 GPU。</strong></p></blockquote><h3 id=trivla-a-triple-system-based-unified-vision-language-action-model-for-general-robot-control>TriVLA: A Triple-System-Based Unified Vision-Language-Action Model for General Robot Control<a hidden class=anchor aria-hidden=true href=#trivla-a-triple-system-based-unified-vision-language-action-model-for-general-robot-control>#</a></h3><p><a href=https://arxiv.org/abs/2507.01424>arxiv</a> <a href=https://zhenyangliu.github.io/TriVLA/>website</a></p><blockquote><p>只有网站，还没有开源相关代码。这个多段其实比较符合我的想法，我觉得端到端直接来是真的不好搞啊。但是这个训练得实在是太耗资源了，要用视频模型预测未来动态场景，直接 8 个 H100 练 2-3 天，太凶猛了。我不看好用视频模型预测未来，没有必要。</p></blockquote><p>这篇论文《TriVLA: A Triple-System-Based Unified Vision-Language-Action Model for General Robot Control》提出了一种<strong>新的三系统统一架构</strong>，用于提升机器人在<strong>动态环境中执行长周期、复杂指令任务</strong>的能力。</p><p><strong>核心创新：三系统架构（Triple-System）</strong></p><table><thead><tr><th>系统编号</th><th>名称</th><th>作用</th><th>技术实现</th></tr></thead><tbody><tr><td><strong>System 2</strong></td><td>Vision-Language Module</td><td>理解语言指令 + 场景语义</td><td>使用预训练 Eagle-2 VLM（SmolLM2 + SigLIP-2）</td></tr><tr><td><strong>System 3</strong></td><td>Dynamics Perception Module</td><td>预测未来动态场景（视频级）</td><td>微调 Stable Video Diffusion（SVD）模型</td></tr><tr><td><strong>System 1</strong></td><td>Policy Learning Module</td><td>生成连续动作序列</td><td>使用 Diffusion Transformer + Flow Matching</td></tr></tbody></table><p><strong>解决的问题</strong></p><table><thead><tr><th>传统方法问题</th><th>TriVLA 如何解决</th></tr></thead><tbody><tr><td>只看当前图像，忽略动态变化</td><td>System 3 预测未来帧，建模动态</td></tr><tr><td>缺乏语言与视觉的深度对齐</td><td>System 2 使用预训练 VLM 处理语言和图像</td></tr><tr><td>动作生成不连贯、频率低</td><td>System 1 使用扩散模型生成动作 chunk，支持 36Hz 控制频率</td></tr></tbody></table><p><strong>实验结果</strong></p><table><thead><tr><th>场景</th><th>数据集</th><th>表现</th></tr></thead><tbody><tr><td><strong>仿真</strong></td><td>CALVIN ABC→D</td><td>平均任务长度 <strong>4.37</strong>（SOTA）</td></tr><tr><td><strong>仿真</strong></td><td>MetaWorld（60任务）</td><td>平均成功率 <strong>71.4%</strong>（优于 VPP、GR-1 等）</td></tr><tr><td><strong>仿真</strong></td><td>LIBERO（4套件）</td><td>在 Spatial/Object/Goal/Long 任务中均领先</td></tr><tr><td><strong>真实机器人</strong></td><td>Franka/Kinova/Fair</td><td>在少量演示下成功完成长周期任务</td></tr></tbody></table><p><strong>关键亮点</strong></p><ul><li><strong>数据效率高</strong>：仅用 10% CALVIN 数据，性能优于全数据训练的 GR-1。</li><li><strong>控制频率高</strong>：36Hz 实时控制，优于传统扩散策略。</li><li><strong>通用性强</strong>：支持不同机器人（Franka、Kinova、Fair）和多视角输入。</li><li><strong>长周期任务能力强</strong>：可处理多步指令，如“打开抽屉→取出方块→放入盒子→关闭抽屉”。</li></ul><h4 id=所需数据-1>所需数据<a hidden class=anchor aria-hidden=true href=#所需数据-1>#</a></h4><table><thead><tr><th>模态</th><th>内容</th><th>格式</th></tr></thead><tbody><tr><td><strong>视觉</strong></td><td>多视角 RGB 图像（静态摄像头 + 手腕摄像头）</td><td>PNG/JPEG</td></tr><tr><td><strong>语言</strong></td><td>自然语言任务指令</td><td>文本</td></tr><tr><td><strong>动作</strong></td><td>连续 7 维动作（末端位姿 + 夹爪状态）</td><td>NumPy 数组</td></tr><tr><td><strong>状态</strong></td><td>机器人关节角度、末端位姿、速度等</td><td>NumPy 数组</td></tr><tr><td><strong>视频</strong></td><td>完整操作视频序列（用于 System 3）</td><td>MP4</td></tr><tr><td><strong>人类操作视频</strong></td><td>互联网人类操作视频（用于预训练）</td><td>MP4</td></tr><tr><td><strong>辅助标签</strong></td><td>可选：深度图、物体掩码、关键点等</td><td>NumPy 数组</td></tr></tbody></table><table><thead><tr><th>数据类型</th><th>来源</th><th>量级</th></tr></thead><tbody><tr><td><strong>人类操作视频</strong></td><td>Something-Something V2、YouTube 等</td><td><strong>193,690 条</strong></td></tr><tr><td><strong>机器人操作视频</strong></td><td>Open X-Embodiment、DROID、CALVIN</td><td><strong>179,074 条</strong></td></tr><tr><td><strong>任务演示视频</strong></td><td>CALVIN、MetaWorld、LIBERO、真实机器人</td><td><strong>每任务 50–100 条</strong></td></tr><tr><td><strong>微调数据</strong></td><td>真实机器人（Franka/Kinova/Fair）</td><td><strong>每任务 100 条轨迹</strong></td></tr></tbody></table><h4 id=三阶段训练流程>三阶段训练流程<a hidden class=anchor aria-hidden=true href=#三阶段训练流程>#</a></h4><p><strong>阶段 1：System 3 视频扩散模型微调（VDM）</strong></p><ul><li><strong>目标</strong>：让视频模型学会预测未来帧（动态感知）</li><li><strong>数据</strong>：<ul><li>人类操作视频（193k）</li><li>机器人操作视频（179k）</li></ul></li><li><strong>训练设置</strong>：<ul><li>模型：Stable Video Diffusion（1.5B 参数）</li><li>损失：扩散重建损失</li><li>训练时间：<strong>2–3 天，8×H100 GPU</strong></li><li>冻结参数：训练完成后冻结 System 3</li></ul></li></ul><p><strong>阶段 2：System 1 策略网络训练（Policy Learning）</strong></p><ul><li><strong>目标</strong>：学习从视觉+语言+动态表示 → 动作的映射</li><li><strong>数据</strong>：<ul><li>CALVIN、MetaWorld、LIBERO、真实机器人演示</li></ul></li><li><strong>训练设置</strong>：<ul><li>模型：Diffusion Transformer（DiT）</li><li>损失：Flow Matching + MSE 动作损失</li><li>训练时间：<strong>5–9 小时，4×H100 GPU</strong></li><li>控制频率：<strong>36 Hz</strong></li><li>动作 chunk 长度：10 步</li></ul></li></ul><p><strong>阶段 3：System 2 VLM 微调（可选）</strong></p><ul><li><strong>目标</strong>：增强语言理解能力（已在 Eagle-2 中预训练）</li><li><strong>数据</strong>：<ul><li>任务指令 + 图像对</li></ul></li><li><strong>训练设置</strong>：<ul><li>模型：Eagle-2（SmolLM2 + SigLIP-2）</li><li>冻结主干，仅微调 LoRA 层</li><li>输入：224×224 图像 + 文本指令</li><li>输出：第 12 层 token（用于策略输入）</li></ul></li></ul><h3 id=chain-of-action-trajectory-autoregressive-modeling-for-robotic-manipulation>Chain-of-Action: Trajectory Autoregressive Modeling for Robotic Manipulation<a hidden class=anchor aria-hidden=true href=#chain-of-action-trajectory-autoregressive-modeling-for-robotic-manipulation>#</a></h3><p>Wenbo Zhang, Tianrun Hu, Yanyuan Qiao, Hanbo Zhang, Yuchu Qin, Yang Li, Jiajun Liu, Tao Kong, Lingqiao Liu, Xiao Ma</p><p>主要是字节的工作</p><p><a href=https://arxiv.org/abs/2506.09990>arxiv</a> <a href=https://github.com/ByteDance-Seed/Chain-of-Action>github (上个月开源, 54 stars)</a></p><blockquote><p>说是比 diffusion policy 要好, 真的假的</p></blockquote><p>这篇论文提出了一种新的机器人操作策略范式 —— <strong>Chain-of-Action（CoA）</strong>，全称是“链式动作轨迹自回归建模”，用于解决传统机器人策略在长时任务中<strong>误差累积严重、空间泛化能力差</strong>的问题。</p><h4 id=-研究背景>📌 研究背景<a hidden class=anchor aria-hidden=true href=#-研究背景>#</a></h4><ul><li><strong>传统方法的问题</strong>：大多数机器人策略采用“正向预测”方式，即根据当前观察逐步预测下一步动作。这种方式容易在长时间任务中累积误差，导致任务失败。</li><li><strong>核心挑战</strong>：如何让机器人策略具备<strong>全局任务目标感知的推理能力</strong>，从而提高长时任务的成功率和空间泛化能力。</li></ul><h4 id=-核心创新chain-of-actioncoa>📌 核心创新：Chain-of-Action（CoA）<a hidden class=anchor aria-hidden=true href=#-核心创新chain-of-actioncoa>#</a></h4><p>CoA 的核心思想是<strong>反向推理动作序列</strong>：</p><ul><li><strong>从任务目标（关键帧动作）出发</strong>，逆向生成整个动作轨迹。</li><li>这种“从目标倒推”的方式天然具有**全局到局部（global-to-local）**的结构，每一步动作都被最终目标所约束，从而显著减少误差累积。</li></ul><h4 id=-四大关键设计>📌 四大关键设计<a hidden class=anchor aria-hidden=true href=#-四大关键设计>#</a></h4><p>为实现上述反向建模，CoA 引入了四项必要机制：</p><table><thead><tr><th>设计组件</th><th>作用</th></tr></thead><tbody><tr><td><strong>连续动作表示</strong></td><td>避免离散化带来的精度损失，适合精细控制。</td></tr><tr><td><strong>多Token预测（MTP）</strong></td><td>同时预测未来多个动作，增强局部一致性。</td></tr><tr><td><strong>动态停止机制</strong></td><td>根据当前状态与目标的接近程度自动决定轨迹长度。</td></tr><tr><td><strong>反向时间集成（Reverse Temporal Ensemble）</strong></td><td>多次反向生成轨迹并集成，提升鲁棒性。</td></tr></tbody></table><h4 id=-实验结果-1>📌 实验结果<a hidden class=anchor aria-hidden=true href=#-实验结果-1>#</a></h4><p><strong>✅ 模拟环境（RLBench，60个任务）</strong></p><ul><li>CoA 相比 ACT（Transformer策略）<strong>提升16.3%</strong>，相比 Diffusion Policy <strong>提升23.2%</strong>。</li><li>在<strong>空间泛化能力</strong>上表现尤为突出，尤其在物体位置变化大的任务中优势明显。</li></ul><p><strong>✅ 真实世界（8个厨房任务，Fetch机器人）</strong></p><ul><li>成功率达 <strong>61.3%</strong>，明显高于 ACT（46.3%）和 Diffusion Policy（36.3%）。</li><li>验证了 CoA 在实际部署中的有效性。</li></ul><p>训练过程分为 <strong>模拟实验（RLBench）</strong> 和 <strong>真实机器人实验</strong> 两部分。</p><p><strong>✅ 1. 模拟实验（RLBench）</strong></p><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td><strong>数据来源</strong></td><td>RLBench 专家演示（Franka Panda 7-DoF 机器人，桌面任务）</td></tr><tr><td><strong>数据内容</strong></td><td>多视角 RGB 图像（128×128），夹爪状态，动作轨迹</td></tr><tr><td><strong>数据量</strong></td><td>每任务 <strong>100 条专家演示</strong>（仅使用 variation 0 以节省计算）</td></tr><tr><td><strong>总任务数</strong></td><td>60 个任务（对比 ACT/DP）；10 个任务（对比 Octo）</td></tr><tr><td><strong>总数据量</strong></td><td>约 <strong>6,000 条演示</strong>（60×100）</td></tr><tr><td><strong>计算资源</strong></td><td><strong>1× NVIDIA H100 GPU</strong>（单卡）</td></tr><tr><td><strong>训练时间</strong></td><td><strong>20,000 步</strong>，batch size = 128，约 <strong>1～2 天</strong></td></tr><tr><td><strong>网络结构</strong></td><td>ResNet-18 + 4层 Transformer Encoder + 7层 Transformer Decoder</td></tr></tbody></table><p><strong>✅ 2. 真实机器人实验（Fetch 机器人）</strong></p><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td><strong>数据来源</strong></td><td>8 个厨房操作任务（如开抽屉、放杯子、关微波炉等）</td></tr><tr><td><strong>数据内容</strong></td><td>单视角 RGB（640×480 → 224×224），夹爪状态，动作轨迹</td></tr><tr><td><strong>数据量</strong></td><td>每任务 <strong>35～81 条专家演示</strong></td></tr><tr><td><strong>总数据量</strong></td><td>约 <strong>400～600 条演示</strong>（8×50 平均值）</td></tr><tr><td><strong>计算资源</strong></td><td><strong>1× NVIDIA RTX 4070 Laptop GPU</strong>（实时推理）</td></tr><tr><td><strong>训练时间</strong></td><td>与模拟设置一致，约 <strong>1～2 天</strong></td></tr><tr><td><strong>推理频率</strong></td><td>策略 10Hz，PD 控制器 1000Hz</td></tr></tbody></table><p><strong>✅ 总结表格</strong></p><table><thead><tr><th>场景</th><th>数据量（每任务）</th><th>总数据量</th><th>计算资源</th><th>训练时间</th></tr></thead><tbody><tr><td><strong>RLBench 模拟</strong></td><td>100 条</td><td>~6,000 条</td><td>1× H100</td><td>~1–2 天</td></tr><tr><td><strong>真实机器人</strong></td><td>35–81 条</td><td>~500 条</td><td>1× 4070 Laptop</td><td>~1–2 天</td></tr></tbody></table><blockquote><p><strong>CoA 每任务仅需几十到上百条专家演示，单张 GPU（H100 或 4070）即可在 1～2 天内完成训练，资源需求远低于视频生成类方法。</strong></p></blockquote><blockquote><p><strong>Chain-of-Action 通过“从目标倒推”的反向动作建模方式，显著提升了机器人策略在长时、复杂任务中的鲁棒性和泛化能力，是一种新的、有前景的机器人动作建模范式。</strong></p></blockquote><h3 id=efficient-robotic-policy-learning-via-latent-space-backward-planning>Efficient Robotic Policy Learning via Latent Space Backward Planning<a hidden class=anchor aria-hidden=true href=#efficient-robotic-policy-learning-via-latent-space-backward-planning>#</a></h3><p>Dongxiu Liu, Haoyi Niu, Zhihao Wang, Jinliang Zheng, Yinan Zheng, Zhonghong Ou, Jianming Hu, Jianxiong Li, Xianyuan Zhan</p><p><a href=https://arxiv.org/abs/2505.06861>arxiv</a> <a href=https://lbp-authors.github.io/>website</a></p><blockquote><p>主页不错, 可以fork. 非常神秘, 和coa一样, 这一篇也是反向操作. 不过训练耗费资源还是相当大的.</p></blockquote><p>这篇文章提出了一种<strong>高效、鲁棒的机器人长时任务规划框架</strong>，名为 <strong>LBP（Latent Space Backward Planning）</strong>，核心思想是：</p><blockquote><p><strong>“从最终目标出发，反向递归地规划中间子目标，从而在长时任务中实现高效、准确、任务一致的规划。”</strong></p></blockquote><h4 id=研究背景与问题>研究背景与问题<a hidden class=anchor aria-hidden=true href=#研究背景与问题>#</a></h4><p>当前机器人规划方法面临一个“效率-精度-一致性”三难困境：</p><table><thead><tr><th>方法类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>细粒度视频预测</strong>（如UniPi、GR-1）</td><td>提供丰富未来信息</td><td>计算昂贵、误差累积严重</td></tr><tr><td><strong>粗粒度子目标规划</strong>（如GCSL、SuSIE）</td><td>计算轻量</td><td>正向规划容易偏离最终目标，导致“跑题”</td></tr></tbody></table><h4 id=-lbp-的核心创新>📌 LBP 的核心创新<a hidden class=anchor aria-hidden=true href=#-lbp-的核心创新>#</a></h4><p><strong>✅ 1. 潜空间建模（Latent Space）</strong></p><ul><li><strong>不在像素空间做规划</strong>，而是在<strong>视觉潜空间</strong>（如DecisionNCE、SigLIP）中进行，大幅降低计算量。</li><li>通过潜空间保留语义信息，同时避免高维图像带来的冗余。</li></ul><p><strong>✅ 2. 反向规划（Backward Planning）</strong></p><ul><li><strong>从最终目标出发</strong>，递归地生成中间子目标，逐步靠近当前状态。</li><li>每一步子目标都<strong>与最终目标对齐</strong>，避免“跑偏”。</li></ul><p><strong>✅ 3. 子目标融合（Goal-Fusion Attention）</strong></p><ul><li>使用 <strong>Perceiver-style Cross-Attention</strong> 动态融合不同距离的子目标信息。</li><li>让策略在不同阶段<strong>自适应地关注短期 vs 长期信息</strong>。</li></ul><table><thead><tr><th>步骤</th><th>说明</th></tr></thead><tbody><tr><td><strong>Step 1：目标生成</strong></td><td>根据当前图像 + 语言指令，预测最终潜空间目标（latent goal）</td></tr><tr><td><strong>Step 2：子目标反向生成</strong></td><td>从目标开始，递归生成中间子目标（由远到近）</td></tr><tr><td><strong>Step 3：策略执行</strong></td><td>用子目标序列作为上下文，训练或引导策略执行动作</td></tr></tbody></table><h4 id=-实验结果-2>📌 实验结果<a hidden class=anchor aria-hidden=true href=#-实验结果-2>#</a></h4><p>✅ LIBERO-LONG 模拟基准（10个长时任务）</p><table><thead><tr><th>方法</th><th>平均成功率</th></tr></thead><tbody><tr><td>LBP（DecisionNCE）</td><td><strong>88.6%</strong> ✅</td></tr><tr><td>Seer</td><td>78.6%</td></tr><tr><td>SuSIE</td><td>76.3%</td></tr><tr><td>OpenVLA</td><td>54.0%</td></tr></tbody></table><blockquote><p>LBP 显著优于所有基线，尤其在多阶段任务中表现突出。</p></blockquote><p>✅ 真实机器人实验（4个长时任务）</p><table><thead><tr><th>任务</th><th>阶段数</th><th>LBP 平均得分</th></tr></thead><tbody><tr><td>Move cups</td><td>2</td><td>77.9 ✅</td></tr><tr><td>Stack 4 cups</td><td>3</td><td>72.5 ✅</td></tr><tr><td>Shift cups</td><td>5</td><td>67.1 ✅</td></tr></tbody></table><blockquote><p>LBP 在<strong>后期阶段</strong>优势显著，说明其<strong>长时一致性更好</strong>。
<strong>LBP 用“从终点倒推”的方式，在潜空间中轻量、准确地规划子目标，显著提升了机器人长时任务的成功率和泛化能力。</strong></p></blockquote><h4 id=训练过程-1>训练过程<a hidden class=anchor aria-hidden=true href=#训练过程-1>#</a></h4><p>✅ 1. <strong>高层规划器（High-Level Planner）</strong></p><blockquote><p>负责生成最终目标（latent goal）和子目标（subgoals）</p></blockquote><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td><strong>所需数据</strong></td><td>专家演示视频（含图像 + 语言指令 + 动作）</td></tr><tr><td><strong>数据量</strong></td><td>每个任务 <strong>50条专家演示</strong>（LIBERO-LONG）每个真实任务 <strong>200条专家演示</strong></td></tr><tr><td><strong>数据格式</strong></td><td>图像（多视角）、语言指令、动作序列</td></tr><tr><td><strong>计算资源</strong></td><td>1× NVIDIA H100 GPU训练 100k steps，batch size = 64</td></tr><tr><td><strong>训练时间</strong></td><td>约 <strong>2~3天</strong>（单卡）</td></tr></tbody></table><p>✅ 2. <strong>低层策略（Low-Level Policy）</strong></p><blockquote><p>根据子目标序列执行动作</p></blockquote><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td><strong>所需数据</strong></td><td>与高层共用（专家演示）</td></tr><tr><td><strong>数据量</strong></td><td>同上（50/200条）</td></tr><tr><td><strong>计算资源</strong></td><td>1× NVIDIA H100 GPU（模拟）1× NVIDIA 4070 Laptop GPU（真实机器人）</td></tr><tr><td><strong>训练时间</strong></td><td>模拟：200k steps（约3<del>4天）真实机器人：400k steps（约5</del>6天）</td></tr></tbody></table><table><thead><tr><th>模块</th><th>数据量（每任务）</th><th>计算资源</th><th>训练时间（单卡）</th></tr></thead><tbody><tr><td>高层规划器</td><td>50（模拟）/ 200（真实）</td><td>1× H100</td><td><del>2</del>3天</td></tr><tr><td>低层策略</td><td>同上</td><td>1× H100（模拟）/ 4070（真实）</td><td>3~6天</td></tr></tbody></table><hr><blockquote><p><strong>每任务只需几十到几百条专家演示视频，单张GPU即可在几天内完成训练，资源门槛远低于视频生成类方法。</strong></p></blockquote><p>如需更低资源版本（如更少数据或更小模型），作者也指出LBP支持灵活压缩子目标数量（如只预测2~3个），可进一步降低训练成本。</p><h2 id=场景重建>场景重建<a hidden class=anchor aria-hidden=true href=#场景重建>#</a></h2><p>四维重建要在三维基础上再加时间，有点猛了</p><h3 id=streamvggt-streaming-4d-visual-geometry-transformer>StreamVGGT: Streaming 4D Visual Geometry Transformer<a hidden class=anchor aria-hidden=true href=#streamvggt-streaming-4d-visual-geometry-transformer>#</a></h3><p>Dong Zhuo*, Wenzhao Zheng*, †, Jiahe Guo, Yuqi Wu, Jie Zhou, Jiwen Lu</p><p>清华的工作，500 stars</p><p><a href=http://wzzheng.net/StreamVGGT/>website</a> <a href=https://arxiv.org/pdf/2507.11539>arxiv</a> <a href=https://github.com/wzzheng/StreamVGGT>github</a></p><blockquote><p><strong>StreamVGGT 是一个基于因果 Transformer 的实时 4D 视觉几何重建模型，支持</strong><br><strong>“逐帧增量更新 + 缓存历史 token 记忆”，在保持 VGGT 级精度的同时实现低延迟在线推理。</strong></p></blockquote><ul><li><strong>4D 重建</strong>：从视频中恢复动态 3D 场景 + 时间维度，是 CV 的基础任务。</li><li><strong>现有问题</strong>：<ul><li><strong>离线模型</strong>（如 VGGT、Fast3R）每次都要重新处理整个序列，无法实时；</li><li><strong>流式模型</strong>（如 Spann3R、CUT3R）虽支持在线更新，但存在误差累积；</li><li><strong>效率瓶颈</strong>：全局注意力复杂度高，不适合长序列。</li></ul></li></ul><p><strong>模型结构</strong></p><table><thead><tr><th>模块</th><th>设计</th><th>作用</th></tr></thead><tbody><tr><td><strong>因果 Transformer</strong></td><td>仅允许当前帧关注历史帧，模拟“人类感知”</td><td>保证因果性，减少计算</td></tr><tr><td><strong>Cached Token Memory</strong></td><td>缓存历史帧的 key/value token，避免重复计算</td><td>实现“增量更新”</td></tr><tr><td><strong>知识蒸馏</strong></td><td>用 VGGT（全局注意力）作为教师，蒸馏到因果学生模型</td><td>抑制误差累积，提升精度</td></tr><tr><td><strong>FlashAttention-2</strong></td><td>集成高效注意力算子</td><td>实现实时推理</td></tr></tbody></table><table><thead><tr><th>模块</th><th>说明</th></tr></thead><tbody><tr><td><strong>Image Encoder</strong></td><td>使用 DINOv2 提取图像 token</td></tr><tr><td><strong>Spatio-Temporal Decoder</strong></td><td>替换 VGGT 的全局注意力为时间因果注意力</td></tr><tr><td><strong>Cached Memory</strong></td><td>缓存历史 token，推理时只处理当前帧</td></tr><tr><td><strong>Multi-Task Heads</strong></td><td>同时输出：• 相机位姿（pose）• 深度图（depth）• 点云图（point map）• 2D 点追踪（tracking）</td></tr></tbody></table><p><strong>实验结果</strong></p><table><thead><tr><th>任务</th><th>数据集</th><th>对比模型</th><th>结果</th></tr></thead><tbody><tr><td><strong>3D 重建</strong></td><td>7-Scenes / NRGBD / ETH3D</td><td>vs CUT3R、Spann3R</td><td><strong>优于 SOTA 流式模型</strong>，接近 VGGT</td></tr><tr><td><strong>单帧深度估计</strong></td><td>KITTI / Sintel / NYU-v2</td><td>vs MonST3R、DUSt3R</td><td><strong>优于所有流式模型</strong></td></tr><tr><td><strong>视频深度估计</strong></td><td>Sintel / Bonn / KITTI</td><td>vs CUT3R、Point3R</td><td><strong>优于 CUT3R</strong></td></tr><tr><td><strong>相机位姿估计</strong></td><td>CO3Dv2</td><td>vs VGGT</td><td><strong>AUC@30 达到 82.4</strong>（接近 VGGT 87.7）</td></tr></tbody></table><p><strong>推理效率</strong></p><table><thead><tr><th>帧数</th><th>VGGT（全局）</th><th>StreamVGGT（流式）</th></tr></thead><tbody><tr><td>N=1</td><td>2089 ms</td><td>386 ms</td></tr><tr><td>N=10</td><td>2000 ms</td><td>67 ms</td></tr><tr><td>N=40</td><td>2089 ms</td><td>68 ms</td></tr></tbody></table><blockquote><p>✅ <strong>StreamVGGT 在长序列下推理时间几乎恒定，VGGT 随帧数线性增长。</strong></p></blockquote><p><strong>局限性</strong></p><table><thead><tr><th>问题</th><th>说明</th></tr></thead><tbody><tr><td><strong>内存膨胀</strong></td><td>缓存 token 随帧数线性增长，不适合超长序列</td></tr><tr><td><strong>教师模型限制</strong></td><td>蒸馏依赖 VGGT，极端场景（高速、非刚性）表现下降</td></tr><tr><td><strong>部署限制</strong></td><td>当前模型较大，不适合移动端</td></tr></tbody></table><h2 id=视频生成>视频生成<a hidden class=anchor aria-hidden=true href=#视频生成>#</a></h2><h3 id=streamdit-real-time-streaming-text-to-video-generation>StreamDiT: Real-Time Streaming Text-to-Video Generation<a hidden class=anchor aria-hidden=true href=#streamdit-real-time-streaming-text-to-video-generation>#</a></h3><p>Akio Kodaira, Tingbo Hou, Ji Hou, Masayoshi Tomizuka, Yue Zhao</p><p>UC Berkeley, Meta</p><p><a href=https://arxiv.org/abs/2507.03745>arxiv</a> <a href=https://cumulo-autumn.github.io/StreamDiT/>website</a></p><blockquote><p>囤在这里,虽然不做视频生成,但是还是要看</p></blockquote><p>这篇文章提出了一种名为 <strong>StreamDiT</strong> 的新型实时流式文本到视频生成模型，旨在解决现有视频生成模型只能离线生成长度有限、短时视频片段的问题。文章的核心贡献和创新点可以总结为以下几点：</p><h4 id=研究背景与问题-1>研究背景与问题<a hidden class=anchor aria-hidden=true href=#研究背景与问题-1>#</a></h4><ul><li><strong>现有问题</strong>：虽然基于扩散变换器（DiT）的文本到视频（T2V）模型在视频质量上取得了显著进展，但它们通常只能离线生成短片段，难以满足实时、交互式应用的需求。</li><li><strong>关键挑战</strong>：如何在保证视频内容一致性和高质量的前提下，实现<strong>流式、实时、长视频</strong>的生成。</li></ul><h4 id=核心贡献>核心贡献<a hidden class=anchor aria-hidden=true href=#核心贡献>#</a></h4><ol><li>提出 <strong>StreamDiT 训练框架</strong></li></ol><ul><li><strong>基于流匹配（Flow Matching）</strong> 的训练方法，引入了一个<strong>滑动缓冲区（moving buffer）</strong> 来处理视频帧序列。</li><li><strong>统一的分区策略（partitioning scheme）</strong>：将缓冲区中的帧划分为多个“块”（chunks），每个块包含多个帧和微步（micro-steps），从而统一了传统扩散模型中的均匀噪声和FIFO-Diffusion中的对角线噪声方法。</li><li><strong>混合训练策略</strong>：在训练中同时使用多种分区方案（如不同的块大小和步数），增强了模型的泛化能力，避免了过拟合某一特定方案。</li></ul><ol start=2><li>设计 <strong>高效的 StreamDiT 模型架构</strong></li></ol><ul><li><strong>基于 adaLN DiT（自适应层归一化的扩散变换器）</strong>，引入了<strong>可变时间嵌入（varying time embedding）</strong> 和<strong>窗口注意力（window attention）</strong>，以提升效率并适应流式生成。</li><li><strong>模型规模</strong>：训练了一个 40 亿参数（4B）的模型，能够在单张 H100 GPU 上实现 16FPS 的实时生成。</li></ul><ol start=3><li>提出 <strong>多步蒸馏（Multistep Distillation）方法</strong></li></ol><ul><li>针对 StreamDiT 的特殊分区设计，定制了蒸馏策略，将原本需要 128 步的去噪过程压缩到 8 步，同时不依赖无分类器引导（CFG），实现了实时推理。</li></ul><h4 id=实验>实验<a hidden class=anchor aria-hidden=true href=#实验>#</a></h4><ul><li><strong>与现有方法对比</strong>：在 VBench 和人类评估中，StreamDiT 在长视频生成的质量、一致性、动态性等方面均优于 ReuseDiffuse 和 FIFO-Diffusion 等现有流式生成方法。</li><li><strong>消融实验</strong>：验证了混合训练策略的有效性，表明混合不同分区方案能提升生成质量。</li><li><strong>应用场景</strong>：<ul><li><strong>实时流式生成</strong>：可实时生成长达 1 分钟以上的视频。</li><li><strong>交互式生成</strong>：用户可实时输入提示词，动态改变视频内容。</li><li><strong>视频到视频编辑</strong>：支持实时视频编辑任务（如将视频中的猪变成猫）。</li></ul></li></ul><blockquote><p><strong>StreamDiT 提出了一种新颖的流式文本到视频生成框架，通过创新的训练策略、高效模型架构和定制蒸馏方法，首次实现了在单张 GPU 上的实时、高质量、长视频生成，为交互式视频应用开辟了新可能。</strong></p></blockquote><h2 id=其他>其他<a hidden class=anchor aria-hidden=true href=#其他>#</a></h2><h3 id=densemixer-improving-moe-post-training-with-precise-router-gradient>DenseMixer: Improving MoE Post-Training with Precise Router Gradient<a hidden class=anchor aria-hidden=true href=#densemixer-improving-moe-post-training-with-precise-router-gradient>#</a></h3><p><strong>Feng Yao$^{\star\dagger}$ Junxia Cui$^{\star}$ Ruohan Zhang$^{\star}$ Liyuan Liu$^{\dagger}$ Shibo Hao Li Zhang Chengyu Dong Shuohang Wang Yelong Shen Jianfeng Gao Jingbo Shang</strong></p><p>$^{\dagger}$: Project Lead; $^{\star}$: Core Contributors; (Work in Progress)</p><p><strong>UCSD, Microsoft</strong></p><p><a href=https://fengyao.notion.site/moe-posttraining>blog</a> <a href=https://github.com/yaof20/DenseMixer>github 两个月前开源，star 58</a></p><blockquote><p>MoE 的优化工作</p></blockquote><p>这篇文章主要介绍了一个新方法 <strong>DenseMixer</strong>，旨在改进 <strong>Mixture-of-Experts（MoE）</strong> 模型的后训练（post‑training）效果。核心内容如下：</p><ol><li><p><strong>研究背景与现有挑战</strong>
MoE 模型相比稠密模型来说训练更困难，关键问题源于其稀疏路由机制（Top‑K router），该机制非可微，导致梯度反向传播复杂。</p></li><li><p><strong>DenseMixer 方法</strong>
论文提出了 DenseMixer 技术，通过在前向传播时对所有专家（包括未激活的专家）进行计算，来获取更加精确的路由梯度。它通过多付出一次前向计算的代价，换取更优的梯度估计。</p></li><li><p><strong>适应性强，使用简单</strong></p><ul><li><strong>兼容性广</strong>：支持不同规模的 MoE（如 7B、14B、30B）、架构（是否共享专家）、预训练方式（从零开始或 “up‑cycling”）、以及不同后训练数据类型（如 instruction tuning 或 long chain-of-thought 数据）。</li><li><strong>方便使用</strong>：只需执行 <code>pip install densemixer</code> 然后 <code>densemixer setup</code>，设置环境变量 <code>DENSEMIXER_ENABLED=1</code> 即可启用 DenseMixer，无需代码更改、推理无额外开销。</li></ul></li><li><p><strong>实验表现优异</strong>
在多个任务的多种模型规模下，DenseMixer 均显著优于传统方法，平均提升一般在 <strong>2% 左右</strong>，在某些评测上甚至更高。</p></li></ol><p>总结来说，这篇文章提出的 <strong>DenseMixer</strong> 是一种简单易用、兼容性强且效果可靠的 MoE 后训练方案，通过改善梯度估计质量来提升模型表现。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://MeteorCollector.github.io/tags/autonomous-driving/>Autonomous Driving</a></li><li><a href=https://MeteorCollector.github.io/tags/vla/>VLA</a></li><li><a href=https://MeteorCollector.github.io/tags/diffusion/>Diffusion</a></li><li><a href=https://MeteorCollector.github.io/tags/reinforcement-learning/>Reinforcement Learning</a></li></ul><nav class=paginav><a class=prev href=https://MeteorCollector.github.io/posts/vla-rl-0818/><span class=title>« Prev</span><br><span>VLA RL Aug '25 B</span>
</a><a class=next href=https://MeteorCollector.github.io/posts/hello_world/><span class=title>Next »</span><br><span>Hello World</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://MeteorCollector.github.io/>MeteorCollectorBlogs</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>